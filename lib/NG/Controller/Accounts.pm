package NG::Controller::Accounts;
use Mojo::Base 'Mojolicious::Controller';
use Data::Dumper;
use Net::Cisco::ACS::User;
use Net::Cisco::ISE::InternalUser;
use Net::Intermapper::User;
use Net::HP::NA::User;

use Digest::MD5 qw(md5_hex);
use MIME::Base64;

my $accounts = {};
my $acsaccounts = {};
my $iseaccounts = {};
my $intermapperaccounts = {};
my $naaccounts = {};

my $status_clean = 0;
my $status_changed = 1; # NG Entry Changed
my $status_created = 2; # NG Entry Created
my $status_deleted = 3; # NG Entry Deleted
my $status_imported = 4; # NG Entry Imported from API - new entry
my $status_synchronized = 5; # NG Entry Synchronized from API - existing entry

sub new_form { # GET /accounts/new - form to create a account   
  my $self = shift;
  $self->redirect_to('/login/') && return if !$self->session('logged_in');
  my $filter = "";
  $self->stash(filter => $filter);
  $self->stash(items => $self->items);  
  my $id = 0;
  my $filterheader = "";
  my $auth_rs = $self->db->resultset('Authentication');
  my $query_rs = $auth_rs->search;
  my $authgroups = { "0" => { "hostname" => "Local", "type" => "-" } };
  
  while (my $authgroup = $query_rs->next)
  { $authgroups->{$authgroup->id}{"hostname"} = $authgroup->hostname;
    $authgroups->{$authgroup->id}{"type"} = $authgroup->type;
  }
  $self->stash(authgroups => $authgroups);

  my %acs_toggle = ();
  my %ise_toggle = ();
  my %im_toggle = ();
  my %na_toggle = ();
  
  my $sources_rs = $self->db->resultset('DsSource');
  $query_rs = $sources_rs->search;
  my %sources = ();

  while (my $source = $query_rs->next)
  { $sources{$source->id} = $source;
  }

  my $account = {};  
  for my $source (keys %sources)
  { $account->{"stub_ise"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ISE";
    $account->{"stub_acs"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ACS";
    $account->{"stub_intermapper"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "Intermapper";
	$account->{"stub_na"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "NA";
  }

  $self->stash(account => $account);
  
  my $acs_rs = $self->db->resultset('DsAcsIdentitygroup');
  $query_rs = $acs_rs->search({});
  my $acsidgroups = {};
  while (my $accountgroup = $query_rs->next)
  { $acsidgroups->{$accountgroup->source->id}{$accountgroup->uid}{"name"} = $accountgroup->name; }
  $self->stash(acsidgroups => $acsidgroups);
  
  my $ise_rs = $self->db->resultset('DsIseIdentitygroup');
  $query_rs = $ise_rs->search;
  my $iseidgroups = {};
  while (my $accountgroup = $query_rs->next)
  { $iseidgroups->{$accountgroup->source->id}{$accountgroup->uid}{"name"} = $accountgroup->name; }
  $self->stash(iseidgroups => $iseidgroups);
  
  my $im_rs = $self->db->resultset('DsIntermapperUser');
  $query_rs = $im_rs->search;
  my $imidgroups = {};
  while (my $accountgroup = $query_rs->next)
  { last unless $accountgroup->groups;
    my (@groups) = split(/\,/,$accountgroup->groups);
    for my $name (@groups)
    { $imidgroups->{$accountgroup->source->id}{$name}{"name"} = $name; }
  } 

  my $na_rs = $self->db->resultset('DsNaGroup');
  $query_rs = $na_rs->search;
  my $naidgroups = {};
  while (my $accountgroup = $query_rs->next)
  { $naidgroups->{$accountgroup->source->id}{$accountgroup->uid}{"name"} = $accountgroup->userGroupName; }
  $self->stash(naidgroups => $naidgroups);
  
  $self->stash(acs_toggle => \%acs_toggle);
  $self->stash(ise_toggle => \%ise_toggle);
  $self->stash(im_toggle => \%im_toggle);
  $self->stash(na_toggle => \%na_toggle);
  my $username = $self->session('username');
  $self->stash(username => $username);

  $self->stash(imidgroups => $imidgroups); 
  $self->render('accounts/create', layout => 'accounts');
}

# This action will render a template
sub show { # GET /accounts/123 - show account with id 123
  my $self = shift;
  $self->redirect_to('/login/') && return if !$self->session('logged_in');
  my $id = $self->param("id"); # Param ID is generated by  Mojox-Scaffold
  my $filter = lc($self->param("filter"));
  $self->consolidate() unless keys %{ $accounts };  
  my $account = $accounts->{$id};
  $self->stash(account => $account);
  my $filterheader = "";
  my $auth_rs = $self->db->resultset('Authentication');
  my $query_rs = $auth_rs->search;
  my $authgroups = { "0" => { "hostname" => "Local", "type" => "-" } };
  
  while (my $authgroup = $query_rs->next)
  { $authgroups->{$authgroup->id}{"hostname"} = $authgroup->hostname;
    $authgroups->{$authgroup->id}{"type"} = $authgroup->type;
    $authgroups->{$authgroup->id}{"selected"} = " selected" if $account->{"authentication"} && $account->{"authentication"} eq $authgroup->id;
  }
  $authgroups->{"0"}{"selected"} = " selected" if $account->{"authentication"} && $account->{"authentication"} eq "0";  
  $self->stash(authgroups => $authgroups);

  my $sources_rs = $self->db->resultset('DsSource');
  $query_rs = $sources_rs->search;
  my $sources = {};
  
  while (my $source = $query_rs->next)
  { $sources->{$source->id} = $source->type->shortname;
  }

  my %acs_toggle = ();
  my %ise_toggle = ();
  my %im_toggle = ();
  my %na_toggle = ();
  my $acsidgroups = {};
  my $iseidgroups = {};  
  my $imidgroups = {};
  my $imidgroupsselected = {};
  my $naidgroups = {};
  
  for my $target (sort keys %{$sources})
  { if ($sources->{$target} eq "ACS")
    { my $acs_rs = $self->db->resultset('DsAcsIdentitygroup');
      my $query_rs = $acs_rs->search;

      while (my $accountgroup = $query_rs->next)
     { $acsidgroups->{$accountgroup->source->id}{$accountgroup->uid}{"name"} = $accountgroup->name;
       $acsidgroups->{$accountgroup->source->id}{$accountgroup->uid}{"selected"} = " selected" if $account->{"acs_identitygroupname"} && $account->{"acs_identitygroupname"} eq $accountgroup->name;
     }
     $acs_toggle{$target} = $account->{"acs"} && $account->{"acs"} ne "fa-close text-danger" ? " checked" : "";
    }
    if ($sources->{$target} eq "ISE")
    { my $ise_rs = $self->db->resultset('DsIseIdentitygroup');
      $query_rs = $ise_rs->search;

      while (my $accountgroup = $query_rs->next)
      { $iseidgroups->{$accountgroup->source->id}{$accountgroup->uid}{"name"} = $accountgroup->name;
        $iseidgroups->{$accountgroup->source->id}{$accountgroup->uid}{"selected"} = " selected" if $account->{"ise_identitygroups"} && $account->{"ise_identitygroups"} eq $accountgroup->name;
      }
      $ise_toggle{$target} = $account->{"ise"} && $account->{"ise"} ne "fa-close text-danger" ? " checked" : "";
    }
    
    if ($sources->{$target} eq "Intermapper")
    { my $im_rs = $self->db->resultset('DsIntermapperUser');
      $query_rs = $im_rs->search;
	  my $imgroups = {};

      #while (my $accountgroup = $query_rs->next)
      #{ if ($accountgroup->name eq $id)
	  #  { my (@groups) = split(/\,/,$accountgroup->groups) if $accountgroup->groups;
	  #    for my $g (@groups) { $imgroups->{$target}{$g}++; }
	  #  }
      #}
      #$query_rs = $im_rs->search;
      while (my $accountgroup = $query_rs->next)
      { my (@groups) = split(/\,/,$accountgroup->groups) if $accountgroup->groups;
        for my $name (@groups)
        { $imidgroups->{$accountgroup->source->id}{$name}{"name"} = $name;
		  #$imidgroupsselected->{$accountgroup->source->id}{$name} = $name if $imgroups->{$accountgroup->source->id}{$name};
        }
      }
      $im_toggle{$target} = $account->{"intermapper"} && $account->{"intermapper"} ne "fa-close text-danger" ? " checked" : "";
    }
    if ($sources->{$target} eq "NA")
    { my $na_rs = $self->db->resultset('DsNaGroup');
      $query_rs = $na_rs->search;
      my $naidgroups = {};

      while (my $accountgroup = $query_rs->next)
      { $naidgroups->{$accountgroup->source->id}{$accountgroup->uid}{"name"} = $accountgroup->userGroupName;
        $naidgroups->{$accountgroup->source->id}{$accountgroup->uid}{"selected"} = " selected" if $account->{"na_groups"} && $account->{"na_groups"} eq $accountgroup->userGroupName;
      }
      $na_toggle{$target} = $account->{"na"} && $account->{"na"} ne "fa-close text-danger" ? " checked" : "";
    }
  }
  $self->stash(acs_toggle => \%acs_toggle);
  $self->stash(ise_toggle => \%ise_toggle);
  $self->stash(im_toggle => \%im_toggle);
  $self->stash(na_toggle => \%na_toggle);
  $self->stash(acsidgroups => $acsidgroups);  
  $self->stash(iseidgroups => $iseidgroups);
  $self->stash(imidgroups => $imidgroups);
  $self->stash(imidgroupsselected => $imidgroupsselected);
  $self->stash(naidgroups => $naidgroups);  
  
  my $username = $self->session('username');
  $self->stash(username => $username);
  $self->stash(items => $self->items);
  $self->stash(filterheader => $filterheader);
  $filter = "?filter=$filter" if $filter;
  $self->stash(filter => $filter);
  $self->render('accounts/detail', layout => 'accounts');
}

sub edit_form { # GET /accounts/123/edit - form to update a account
}

# This action will render a template
sub index { # GET /accounts - list of all accounts
  my $self = shift;
  $self->redirect_to('/login/') && return if !$self->session('logged_in');
  $self->consolidate();
  my $filter = lc($self->param("filter"));
  my %accounts = %{ $accounts };
  my %status = ();
  for my $account (keys %accounts)
  { #for my $key (qw(acs ise ad ldap nagios hpna intermapper cacti))
    for my $key (qw(acs ise intermapper na))
    { $status{$account}{$key} = ($accounts->{$account}{$key} && $accounts->{$account}{$key} ne "fa-close text-danger") ? "fa-check text-success" : "fa-close text-danger";
    }
  }
  $self->stash(status => \%status);
  my $filterheader = "";
  if ($filter)
  { my %accounts = %{ $accounts };
    my @keys = grep { $status{$_}{$filter} ne "fa-close text-danger" } keys %accounts;
    my %filteraccounts = ();
    @filteraccounts{@keys} = @accounts{@keys};
    $self->stash(accounts => \%filteraccounts);
    $filterheader = $self->items->{$filter}->type->shortname ." Accounts - " if $self->items->{$filter};
  } else
  {  $self->stash(accounts => $accounts); }
  my $username = $self->session('username');
  $self->stash(username => $username);

  $self->stash(items => $self->items);
  $self->stash(filterheader => $filterheader);
  $filter = "?filter=$filter" if $filter;
  $self->stash(filter => $filter);
  $self->render('accounts/index', layout => 'accounts');
}

sub create { # POST /accounts - create new account
  my $self = shift;
  $self->redirect_to('/login/') && return if !$self->session('logged_in');  

  my $param = $self->req->params->names;
  my @paramnames = @{$param};
    
  # Temporary fix - Implement UID generation too! TODO
  my $amax = $self->db->resultset('Account')->get_column('Id');
  my $amaxid = $amax->max;
  $amaxid++;

  my $acs_rs = $self->db->resultset('DsAcsUser');
  my $query_rs = $acs_rs->search({ name => "__default" });
  my $defaultacs = $query_rs->first;

  my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
  $query_rs = $intermapper_rs->search({ name => "__default" });
  my $defaultintermapper = $query_rs->first;

  my $ise_rs = $self->db->resultset('DsIseInternaluser');
  $query_rs = $ise_rs->search({ name => "__default" });
  my $defaultise = $query_rs->first;

  my $na_rs = $self->db->resultset('DsNaUser');
  $query_rs = $na_rs->search({ name => "__default" });
  my $defaultna = $query_rs->first;
  
  my @acs_uid = @{ $self->every_param('acs_uid') };
  my @ise_uid = @{ $self->every_param('ise_uid') };
  my @im_uid = @{ $self->every_param('im_uid') };
  my @na_uid = @{ $self->every_param('na_uid') };
  
  my $acs_toggle = $self->param("acs_toggle") || "0";
  my $ise_toggle = $self->param("ise_toggle") || "0";
  my $im_toggle = $self->param("im_toggle") || "0";
  my $password = $self->param("password");
  my $authentication = $self->param("authentication");
  my $name = $self->param("name");
  my $encpassword = encode_base64($self->cipher->encrypt($self->salt.$password.$name));

  $self->db->resultset('Account')->create({
            name => $name,
            password => $password,
            id => $amaxid,
            uid => $amaxid, # TODO: This may need to be fixed
            authentication => $authentication,
        });
   
  for my $uid (@acs_uid)
  { my ($source) = $uid =~ /^(.*?)\-X$/;
    my $acs_toggle = $self->param("acs_toggle_".$uid) || "0";
    my $acs_password = $self->param("acs_password_".$uid) || $password;
    my $encacspassword = encode_base64($self->cipher->encrypt($self->salt.$acs_password.$name));
    my $acs_enabled = $self->param("acs_enabled_".$uid);  
    my $acs_description = $self->param("acs_description_".$uid);
    my $acs_identitygroupname = $self->param("acs_identitygroupname_".$uid);
    my $acs_enablepassword = $self->param("acs_enablepassword_".$uid);
    my $acs_encenablepassword = encode_base64($self->cipher->encrypt($self->salt.$acs_enablepassword.$name));
    my $acs_passwordneverexpires = $self->param("acs_passwordneverexpires_".$uid);
    my $acs_dateexceedsenabled = $self->param("acs_dateexceedsenabled_".$uid);
    my $acs_dateexceeds = $self->param("acs_dateexceeds_".$uid);
    my $acs_passwordtype = $self->param("acs_passwordtype_".$uid);      
         
    my $checksum = md5_hex($name.$encacspassword.$acs_enabled.$acs_description.$acs_identitygroupname.$acs_enablepassword.$acs_passwordneverexpires.$acs_dateexceedsenabled.
                         $acs_dateexceeds.$acs_passwordtype);
  
    # Temporary fix
    my $acsmax = $self->db->resultset('DsAcsUser')->get_column('Id');
    my $acsmaxid = $acsmax->max;
    $acsmaxid++;
  
    # Need to store full datetime instead of date
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    $mon++;
    $year += 1900;  
    my @months = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec); 
    my $lastmodified = "$months[$mon] $mday $year $hour:$min:$sec";
    my $created = "$months[$mon] $mday $year $hour:$min:$sec";
    $uid = "$source-$acsmaxid";
    my $id = $name;
    if ($defaultacs)
    { $acs_enabled ||= $defaultacs->enabled;  
      $acs_description ||= $defaultacs->description;
      $acs_identitygroupname ||= $defaultacs->identitygroupname;
      $acs_enablepassword ||= $defaultacs->enablepassword;
      $acs_passwordneverexpires ||=  $defaultacs->passwordneverexpires;
      $acs_dateexceedsenabled ||= $defaultacs->dateexceedsenabled;
      $acs_dateexceeds ||=  $defaultacs->dateexceeds;
      $acs_passwordtype ||= $defaultacs->passwordtype;
    }

    if ($uid && $acs_toggle)
    { $accounts->{$id}{"acs"}{$uid}{"enabled"} = $acs_enabled;
      $accounts->{$id}{"acs"}{$uid}{"description"} = $acs_description;
      $accounts->{$id}{"acs"}{$uid}{"identitygroupname"} = $acs_identitygroupname;
      $accounts->{$id}{"acs"}{$uid}{"enablepassword"} = $acs_encenablepassword;
      $accounts->{$id}{"acs"}{$uid}{"passwordneverexpires"} = $acs_passwordneverexpires;
      $accounts->{$id}{"acs"}{$uid}{"dateexceedsenabled"} = $acs_dateexceedsenabled;
      $accounts->{$id}{"acs"}{$uid}{"dateexceeds"} = $acs_dateexceeds;
      $accounts->{$id}{"acs"}{$uid}{"passwordtype"} = $acs_passwordtype;
      $accounts->{$id}{"acs"}{$uid}{"lastmodified"} = $lastmodified;
      $accounts->{$id}{"acs"}{$uid}{"password"} = $encacspassword;

      $self->db->resultset('DsAcsUser')->create(
        { enabled => $acs_enabled, description => $acs_description, identitygroupname => $acs_identitygroupname,
          enablepassword => $acs_enablepassword, passwordneverexpires => $acs_passwordneverexpires,
          dateexceedsenabled => $acs_dateexceedsenabled, dateexceeds => $acs_dateexceeds, passwordtype => $acs_passwordtype,
          name => $name, password => $acs_password, id => $acsmaxid, status => $status_created, source=> $source,
          uid => $uid, id => $acsmaxid, lastmodified => $lastmodified, created => $created
        });
    }
  }
  
  for my $uid (@ise_uid)
  { my ($source) = $uid =~ /^(.*?)\-X$/;
    my $ise_toggle = $self->param("ise_toggle_".$uid) || "0";
    my $ise_password = $self->param("ise_password_".$uid) || $password;
    my $encisepassword = encode_base64($self->cipher->encrypt($self->salt.$ise_password.$name));
    my $ise_enabled = $self->param("ise_enabled_".$uid);
    my $ise_firstname = $self->param("ise_firstname_".$uid);
    my $ise_lastname = $self->param("ise_lastname_".$uid); 
    my $ise_identitygroups = $self->param("ise_identitygroups_".$uid);
    my $ise_email = $self->param("ise_email_".$uid);  
    my $ise_enablepassword = $self->param("ise_enablepassword_".$uid);
    my $ise_encenablepassword = encode_base64($self->cipher->encrypt($self->salt.$ise_enablepassword.$name));
    my $id = $name;

    # Temporary fix
    my $isemax = $self->db->resultset('DsIseInternaluser')->get_column('Id');
    my $isemaxid = $isemax->max;
    $isemaxid++;

    $uid = "$source-$isemaxid";
    my $ise_changepassword = $self->param("ise_changepassword");
    my $ise_expirydateenabled = $self->param("ise_expirydateenabled");
    my $ise_expirydate = $self->param("ise_expirydate");
    my $ise_passwordidstore = $self->param("ise_passwordidstore");
    my $checksum = md5_hex($name.$encisepassword.$ise_enabled.$ise_firstname.$ise_lastname.$ise_identitygroups.$ise_email.$ise_encenablepassword.
                      $ise_changepassword.$ise_expirydateenabled.$ise_expirydate.$ise_passwordidstore);

    if ($defaultise) 
    { $ise_enabled ||= $defaultise->enabled;
      $ise_firstname ||= $defaultise->firstname;
      $ise_lastname ||= $defaultise->lastname; 
      $ise_identitygroups ||= $defaultise->identitygroups;
      $ise_email ||= $defaultise->email;  
      $ise_enablepassword ||= $defaultise->enablepassword;
      $ise_changepassword ||= $defaultise->changepassword;
      $ise_expirydateenabled ||= $defaultise->expirydateenabled;
      $ise_expirydate ||= $defaultise->expirydate;
      $ise_passwordidstore ||= $defaultise->passwordidstore;
    }

    if ($uid && $ise_toggle)
    { $accounts->{$id}{"ise"}{$uid}{"enabled"} = $ise_enabled;
      $accounts->{$id}{"ise"}{$uid}{"firstname"} = $ise_firstname;
      $accounts->{$id}{"ise"}{$uid}{"lasttname"} = $ise_lastname;    
      $accounts->{$id}{"ise"}{$uid}{"identitygroups"} = $ise_identitygroups;
      $accounts->{$id}{"ise"}{$uid}{"email"} = $ise_email;    
      $accounts->{$id}{"ise"}{$uid}{"enablepassword"} = $ise_encenablepassword;
      $accounts->{$id}{"ise"}{$uid}{"changepassword"} = $ise_changepassword;
      $accounts->{$id}{"ise"}{$uid}{"expirydateenabled"} = $ise_expirydateenabled;
      $accounts->{$id}{"ise"}{$uid}{"expirydate"} = $ise_expirydate;
      $accounts->{$id}{"ise"}{$uid}{"passwordidstore"} = $ise_passwordidstore;
      $accounts->{$id}{"ise"}{$uid}{"password"} = $encisepassword;
  
      my $encisepassword = encode_base64($self->cipher->encrypt($self->salt.$ise_password.$name));

      $self->db->resultset('DsIseInternaluser')->create(
          { enabled => $ise_enabled, firstname => $ise_firstname, lastname => $ise_lastname,
            identitygroups => $ise_identitygroups, email => $ise_email, enablepassword => $ise_encenablepassword,
            changepassword => $ise_changepassword, expirydateenabled => $ise_expirydateenabled, expirydate=> $ise_expirydate,
            passwordidstore => $ise_passwordidstore, name => $name, password => $encisepassword, status => $status_created,
            id => $isemaxid, checksum => $checksum, source => $source, uid => $uid,
          });
    }
  }
  
  for my $uid (@im_uid)  
  { my $im_password = $self->param("intermapper_password_".$uid) || $password;
    my $encimpassword = encode_base64($self->cipher->encrypt($self->salt.$im_password.$name));

    my $intermapper_groups = $self->param("intermapper_groups_".$uid);
    my $intermapper_guest = $self->param("intermapper_guest_".$uid);
    my $intermapper_external = $self->param("intermapper_external_".$uid);
    my $checksum = md5_hex($name.$encimpassword.$intermapper_groups.$intermapper_guest.$intermapper_external);
    my $id = $name;
    if ($defaultintermapper)
    { $intermapper_groups ||= $defaultintermapper->groups;
      $intermapper_guest ||= $defaultintermapper->guest;
      $intermapper_external ||= $defaultintermapper->external;
    }

    # Temporary fix
    my @chars = ("A".."Z", "a".."z","0".."9");
    my $immaxid;
    $immaxid .= $chars[rand @chars] for 1..8;
    
    if ($uid && $im_toggle)
    { my ($source) = $uid =~ /^(.*?)\-X$/;
      $accounts->{$id}{"intermapper"}{$uid}{"groups"} = $intermapper_groups;
      $accounts->{$id}{"intermapper"}{$uid}{"guest"} = $intermapper_guest;
      $accounts->{$id}{"intermapper"}{$uid}{"external"} = $intermapper_external;
      $accounts->{$id}{"intermapper"}{$uid}{"password"} = $encimpassword;
      $uid = "$source-$immaxid";

      $self->db->resultset('DsIntermapperUser')->create(
      { groups => $intermapper_groups, external => $intermapper_external, guest => $intermapper_guest,
        name => $name, password => $encimpassword, status => $status_created, id => $immaxid, checksum => $checksum,
        source => $source, uid => $uid
       });
    }
  }

  for my $uid (@na_uid)
  { my ($source) = $uid =~ /^(.*?)\-X$/;
    my $na_toggle = $self->param("na_toggle_".$uid) || "0";
    my $na_userpassword = $self->param("na_userpassword_".$uid) || $password;
    my $encnapassword = encode_base64($self->cipher->encrypt($self->salt.$na_userpassword.$name));
    my $na_aaapassword = $self->param("na_aaapassword_".$uid) || $password;
    my $encnaaaapassword = encode_base64($self->cipher->encrypt($self->salt.$na_aaapassword.$name));
	my $na_emailaddress = $self->param("na_emailaddress_".$uid);
	my $na_comments = $self->param("na_comments_".$uid);
	my $na_distinguishedname = $self->param("na_distinguishedname_".$uid);
	my $na_allowfailover = $self->param("na_allowfailover_".$uid);
	my $na_username = $self->param("na_username_".$uid);
	my $na_timezone = $self->param("na_timezone_".$uid);
	my $na_firstname = $self->param("na_firstname_".$uid);
	my $na_useaaaloginforproxy = $self->param("na_useaaaloginforproxy_".$uid);
	my $na_privilegelevel = $self->param("na_privilegelevel_".$uid);
	my $na_passwordoption = $self->param("na_passwordoption_".$uid);
	my $na_aaausername = $self->param("na_aaausername_".$uid);
	my $na_status = $self->param("na_status_".$uid);
	my $na_ticketnumber = $self->param("na_ticketnumber_".$uid);
	my $na_lastname = $self->param("na_lastname_".$uid);
	
	my $checksum = "";
    #my $checksum = md5_hex($name.$encacspassword.$acs_enabled.$acs_description.$acs_identitygroupname.$acs_enablepassword.$acs_passwordneverexpires.$acs_dateexceedsenabled.
    #                     $acs_dateexceeds.$acs_passwordtype);
  
    # Temporary fix
    my $namax = $self->db->resultset('DsNaUser')->get_column('userid');
    my $namaxid = $namax->max;
    $namaxid++;

    # Need to store full datetime instead of date
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    $mon++;
    $year += 1900;  
    my @months = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec); 
    my $lastmodified = "$months[$mon] $mday $year $hour:$min:$sec";
    my $created = "$months[$mon] $mday $year $hour:$min:$sec";
    $uid = "$source-$namaxid";
    my $id = $name;
    if ($defaultna)
    { $na_userpassword ||= $defaultna->userpassword;
	  $na_aaapassword ||= $defaultna->aaapassword;
	  $na_emailaddress ||= $defaultna->emailaddress;
	  $na_comments ||= $defaultna->comments;
	  $na_distinguishedname ||= $defaultna->distinguishedname;
	  $na_allowfailover ||= $defaultna->allowfailover;
	  $na_username ||= $defaultna->username;
	  $na_timezone ||= $defaultna->timezone;
	  $na_firstname ||= $defaultna->firstname;
	  $na_useaaaloginforproxy ||= $defaultna->useaaaloginforproxy;
	  $na_privilegelevel ||= $defaultna->privilegelevel;
	  $na_passwordoption ||= $defaultna->passwordoption;
	  $na_aaausername ||= $defaultna->aaausername;
	  $na_status ||= $defaultna->status;
	  $na_ticketnumber ||= $defaultna->ticketnumber;
	  $na_lastname ||= $defaultna->lastname;
    }

    if ($uid && $na_toggle)
    { $accounts->{$id}{"na"}{$uid}{"userpassword"} = $na_userpassword;
	  $accounts->{$id}{"na"}{$uid}{"aaapassword"} = $na_aaapassword;
	  $accounts->{$id}{"na"}{$uid}{"emailaddress"} = $na_emailaddress;
	  $accounts->{$id}{"na"}{$uid}{"comments"} = $na_comments;
	  $accounts->{$id}{"na"}{$uid}{"distinguishedname"} = $na_distinguishedname;
	  $accounts->{$id}{"na"}{$uid}{"allowfailover"} = $na_allowfailover;
	  $accounts->{$id}{"na"}{$uid}{"username"} = $na_username;
	  $accounts->{$id}{"na"}{$uid}{"timezone"} = $na_timezone;
	  $accounts->{$id}{"na"}{$uid}{"firstname"} = $na_firstname;
	  $accounts->{$id}{"na"}{$uid}{"useaaaloginforproxy"} = $na_useaaaloginforproxy;
	  $accounts->{$id}{"na"}{$uid}{"privilegelevel"} = $na_privilegelevel;
	  $accounts->{$id}{"na"}{$uid}{"passwordoption"} = $na_passwordoption;
	  $accounts->{$id}{"na"}{$uid}{"aaausername"} = $na_aaausername;
	  $accounts->{$id}{"na"}{$uid}{"status"} = $na_status;
	  $accounts->{$id}{"na"}{$uid}{"ticketnumber"} = $na_ticketnumber;
	  $accounts->{$id}{"na"}{$uid}{"lastname"} = $na_lastname;

      $self->db->resultset('DsNaUser')->create(
        { userpassword => $na_userpassword, emailaddress => $na_emailaddress, comments => $na_comments, aaapassword => $na_aaapassword,
		  distinguishedname => $na_distinguishedname, allowfailover => $na_allowfailover, username => $na_username, timezone => $na_timezone,
		  firstname => $na_firstname, useaaaloginforproxy => $na_useaaaloginforproxy, privilegelevel => $na_privilegelevel, lastname => $na_lastname,
		  passwordoption => $na_passwordoption, aaausername => $na_aaausername, status => $na_status, ticketnumber => $na_ticketnumber,
		  id => $namaxid, na_status => $status_created, source=> $source, uid => $uid, #lastmodified => $lastmodified, created => $created,
        });
    }
  }

  $self->redirect_to("/accounts/");
}

sub update { # PUT /accounts/123 - update a account
  my $self = shift;
  $self->redirect_to('/login/') && return if !$self->session('logged_in');
  my $id = $self->param("id");

  my $param = $self->req->params->names;
  my @paramnames = @{$param};

  my @acs_uid = @{ $self->every_param('acs_uid') };
  my @ise_uid = @{ $self->every_param('ise_uid') };
  my @im_uid = @{ $self->every_param('im_uid') };
  my @na_uid = @{ $self->every_param('na_uid') };  
  my $password = $self->param("password");
  my $authentication = $self->param("authentication");
  my $name = $self->param("name");
  my $encpassword = encode_base64($self->cipher->encrypt($self->salt.$password.$name));
  for my $uid (@acs_uid)
  { my $acs_toggle = $self->param("acs_toggle_".$uid) || "0";
    my $acs_password = $self->param("acs_password_".$uid) || $password;
    my $encacspassword = encode_base64($self->cipher->encrypt($self->salt.$acs_password.$name));
    my $acs_enabled = $self->param("acs_enabled_".$uid);  
    my $acs_description = $self->param("acs_description_".$uid);
    my $acs_identitygroupname = $self->param("acs_identitygroupname_".$uid);
    my $acs_enablepassword = $self->param("acs_enablepassword_".$uid);
    my $acs_encenablepassword = encode_base64($self->cipher->encrypt($self->salt.$acs_enablepassword.$name));
    my $acs_passwordneverexpires = $self->param("acs_passwordneverexpires_".$uid);
    my $acs_dateexceedsenabled = $self->param("acs_dateexceedsenabled_".$uid);
    my $acs_dateexceeds = $self->param("acs_dateexceeds_".$uid);
    my $acs_passwordtype = $self->param("acs_passwordtype_".$uid);
  
    # Need to store full datetime instead of date
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    $mon++;
    $year += 1900;  
    my @months = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec); 
    my $lastmodified = "$months[$mon] $mday $year $hour:$min:$sec";
    my $created = "$months[$mon] $mday $year $hour:$min:$sec";

    # Temporary fix
    my $acsmax = $self->db->resultset('DsAcsUser')->get_column('Id');
    my $acsmaxid = $acsmax->max;
    $acsmaxid++;
    my ($source) = $uid =~ /^(.*?)\-X$/;
    if ($uid =~ /\-X$/) { $uid = ""; }
    if ($uid && $acs_toggle)
    { $accounts->{$id}{"acs"}{$uid}{"enabled"} = $acs_enabled;
      $accounts->{$id}{"acs"}{$uid}{"description"} = $acs_description;
      $accounts->{$id}{"acs"}{$uid}{"identitygroupname"} = $acs_identitygroupname;
      $accounts->{$id}{"acs"}{$uid}{"enablepassword"} = $acs_encenablepassword;
      $accounts->{$id}{"acs"}{$uid}{"passwordneverexpires"} = $acs_passwordneverexpires;
      $accounts->{$id}{"acs"}{$uid}{"dateexceedsenabled"} = $acs_dateexceedsenabled;
      $accounts->{$id}{"acs"}{$uid}{"dateexceeds"} = $acs_dateexceeds;
      $accounts->{$id}{"acs"}{$uid}{"passwordtype"} = $acs_passwordtype;
      $accounts->{$id}{"acs"}{$uid}{"lastmodified"} = $lastmodified;
      $accounts->{$id}{"acs"}{$uid}{"password"} = $encacspassword;
      my $acs_rs = $self->db->resultset('DsAcsUser');
      my $query_rs = $acs_rs->search({ uid => $uid });

      $encacspassword = $acs_password eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->password : $encacspassword;
      $acs_encenablepassword = $acs_enablepassword eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->enablepassword : $acs_enablepassword;

      # TODO Checksum needs to be implemented properly  
      my $checksum = md5_hex($name.$encacspassword.$acs_enabled.$acs_description.$acs_identitygroupname.$acs_enablepassword.$acs_passwordneverexpires.$acs_dateexceedsenabled.
                         $acs_dateexceeds.$acs_passwordtype);

      $query_rs->first->update({ enabled => $acs_enabled, description => $acs_description, identitygroupname => $acs_identitygroupname,
                       enablepassword => $acs_encenablepassword, passwordneverexpires => $acs_passwordneverexpires,
                       dateexceedsenabled => $acs_dateexceedsenabled, dateexceeds => $acs_dateexceeds, passwordtype => $acs_passwordtype,
                       name => $name, password => $encacspassword, status => $status_changed, lastmodified => $lastmodified, checksum => $checksum
                    });
    }
    if (!$uid && $acs_toggle) # TODO: UID is, at this point, ALWAYS defined!!
    { if ($acs_enabled || $acs_description || $acs_identitygroupname || $acs_encenablepassword || $acs_passwordneverexpires || $acs_dateexceedsenabled ||
          $acs_dateexceeds || $acs_passwordtype)
      { my $checksum = md5_hex($name.$encacspassword.$acs_enabled.$acs_description.$acs_identitygroupname.$acs_enablepassword.$acs_passwordneverexpires.$acs_dateexceedsenabled.
                         $acs_dateexceeds.$acs_passwordtype);
        # TODO Checksum needs to be properly implemented
        $uid = "$source-$acsmaxid";
        $self->db->resultset('DsAcsUser')->create(
        { enabled => $acs_enabled, description => $acs_description, identitygroupname => $acs_identitygroupname,
          enablepassword => $acs_encenablepassword, passwordneverexpires => $acs_passwordneverexpires, uid => $uid,
          dateexceedsenabled => $acs_dateexceedsenabled, dateexceeds => $acs_dateexceeds, passwordtype => $acs_passwordtype, checksum => $checksum,
          name => $name, password => $encacspassword, status => $status_created, id => $acsmaxid, lastmodified => $lastmodified, created => $created
        });
        $accounts->{$uid}{"acs_created"} = $created; # Confirm this?!?
      }
    }
  
    if ($uid && !$acs_toggle)  
    { my $acs_rs = $self->db->resultset('DsAcsUser');
      my $query_rs = $acs_rs->search({ uid => $uid });
      #$query_rs->delete;
      $query_rs->first->update({status => $status_deleted});
      delete($acsaccounts->{$uid});
      # TODO Add support for delete flag & remove hash delete
      $accounts->{$uid}{"acs"} = 0;
    }
  }
  
  for my $uid (@ise_uid)
  { my $ise_toggle = $self->param("ise_toggle_".$uid) || "0";
    my $ise_password = $self->param("ise_password_".$uid) || $password;
    my $encisepassword = encode_base64($self->cipher->encrypt($self->salt.$ise_password.$name));
    my $ise_enabled = $self->param("ise_enabled_".$uid);
    my $ise_firstname = $self->param("ise_firstname_".$uid);
    my $ise_lastname = $self->param("ise_lastname_".$uid); 
    my $ise_identitygroups = $self->param("ise_identitygroups_".$uid);
    my $ise_email = $self->param("ise_email_".$uid);  
    my $ise_enablepassword = $self->param("ise_enablepassword_".$uid);
    my $ise_encenablepassword = encode_base64($self->cipher->encrypt($self->salt.$ise_enablepassword.$name));
    
    # Temporary fix
    my $isemax = $self->db->resultset('DsIseIdentitygroup')->get_column('Id');
    my $isemaxid = $isemax->max;
    $isemaxid++;  
        
    my $ise_changepassword = $self->param("ise_changepassword");
    my $ise_expirydateenabled = $self->param("ise_expirydateenabled");
    my $ise_expirydate = $self->param("ise_expirydate");
    my $ise_passwordidstore = $self->param("ise_passwordidstore");
    my ($source) = $uid =~ /^(.*?)\-X$/;
    if ($uid =~ /\-X$/) { $uid = ""; }
    if ($uid && $ise_toggle)
    { $accounts->{$id}{"ise"}{$uid}{"enabled"} = $ise_enabled;
      $accounts->{$id}{"ise"}{$uid}{"firstname"} = $ise_firstname;
      $accounts->{$id}{"ise"}{$uid}{"lasttname"} = $ise_lastname;    
      $accounts->{$id}{"ise"}{$uid}{"identitygroups"} = $ise_identitygroups;
      $accounts->{$id}{"ise"}{$uid}{"email"} = $ise_email;    
      $accounts->{$id}{"ise"}{$uid}{"enablepassword"} = $ise_encenablepassword;
      $accounts->{$id}{"ise"}{$uid}{"changepassword"} = $ise_changepassword;
      $accounts->{$id}{"ise"}{$uid}{"expirydateenabled"} = $ise_expirydateenabled;
      $accounts->{$id}{"ise"}{$uid}{"expirydate"} = $ise_expirydate;
      $accounts->{$id}{"ise"}{$uid}{"passwordidstore"} = $ise_passwordidstore;
      $accounts->{$id}{"ise"}{$uid}{"password"} = $encisepassword;
      my $ise_rs = $self->db->resultset('DsIseInternaluser');
      my $query_rs = $ise_rs->search({ uid => $uid });
      $encisepassword = $ise_password eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->password : $encisepassword;
      $ise_encenablepassword = $ise_enablepassword eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->enablepassword : $ise_enablepassword;
      
      my $checksum = md5_hex($name.$encisepassword.$ise_enabled.$ise_firstname.$ise_lastname.$ise_identitygroups.$ise_email.$ise_encenablepassword.
                      $ise_changepassword.$ise_expirydateenabled.$ise_expirydate.$ise_passwordidstore);
      # TODO Checksum needs to be implemented properly
      if ($query_rs)
      { $query_rs->first->update({ enabled => $ise_enabled, firstname => $ise_firstname, lastname => $ise_lastname,
                       identitygroups => $ise_identitygroups, email => $ise_email, enablepassword => $ise_encenablepassword,
                       changepassword => $ise_changepassword, expirydateenabled => $ise_expirydateenabled, expirydate=> $ise_expirydate,
                       passwordidstore => $ise_passwordidstore, name => $name, password => $encisepassword, status => $status_changed, checksum => $checksum
                    });
      }
    }
  
    if (!$uid && $ise_toggle) # TODO: UID is, at this point, ALWAYS defined!!
    { if ($ise_enabled || $ise_firstname || $ise_lastname || $ise_identitygroups || $ise_email || $ise_encenablepassword ||
          $ise_changepassword || $ise_expirydateenabled || $ise_expirydate || $ise_passwordidstore)
        { my $checksum = md5_hex($name.$encisepassword.$ise_enabled.$ise_firstname.$ise_lastname.$ise_identitygroups.$ise_email.$ise_encenablepassword.
                      $ise_changepassword.$ise_expirydateenabled.$ise_expirydate.$ise_passwordidstore);
          $uid = "$source-$isemaxid";
          # TODO Checksum needs to be implemented properly
          $self->db->resultset('DsIseInternaluser')->create(
          { enabled => $ise_enabled, firstname => $ise_firstname, lastname => $ise_lastname,
            identitygroups => $ise_identitygroups, email => $ise_email, enablepassword => $ise_encenablepassword, source => $source,
            changepassword => $ise_changepassword, expirydateenabled => $ise_expirydateenabled, expirydate=> $ise_expirydate, uid => $uid,
            passwordidstore => $ise_passwordidstore, name => $name, password => $encisepassword, status => $status_created, id => $isemaxid, checksum => $checksum
          });
       }
    }

    if ($uid && !$ise_toggle)  
    { my $ise_rs = $self->db->resultset('DsIseInternaluser');
      my $query_rs = $ise_rs->search({ uid => $uid });
      #$query_rs->delete;
      # TODO Add support for delete flag & remove hash delete
      delete($iseaccounts->{$uid});
      $query_rs->first->update({status => $status_deleted});
      $accounts->{$uid}{"ise"} = 0;
    }
  }

  for my $uid (@im_uid)  
  { my $im_password = $self->param("intermapper_password_".$uid) || $password;
    my $encimpassword = encode_base64($self->cipher->encrypt($self->salt.$im_password.$name));

    # Intermapper IDs are random IDs
    my @chars = ("A".."Z", "a".."z","0".."9");
    my $immaxid;
    $immaxid .= $chars[rand @chars] for 1..8;
        
    my $intermapper_groups = $self->param("intermapper_groups_".$uid);
    my $intermapper_guest = $self->param("intermapper_guest_".$uid);
    my $intermapper_external = $self->param("intermapper_external_".$uid);
    my $im_toggle = $self->param("im_toggle_".$uid) || "0";
    my ($source) = $uid =~ /^(.*?)\-X$/;
    if ($uid =~ /\-X$/) { $uid = ""; }
    if ($uid && $im_toggle)
    { $accounts->{$id}{"intermapper"}{$uid}{"groups"} = $intermapper_groups;
      $accounts->{$id}{"intermapper"}{$uid}{"guest"} = $intermapper_guest;
      $accounts->{$id}{"intermapper"}{$uid}{"external"} = $intermapper_external;
      $accounts->{$id}{"intermapper"}{$uid}{"password"} = $encimpassword;
      my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
      my $query_rs = $intermapper_rs->search({ uid => $uid });
      $encimpassword = $im_password eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->password : $encimpassword; 
      my $checksum = md5_hex($name.$encimpassword.$intermapper_groups.$intermapper_guest.$intermapper_external);
      # TODO Checksum needs to be properly implemented

      $query_rs->first->update({ groups => $intermapper_groups, external => $intermapper_external, guest => $intermapper_guest,
                      name => $name, password => $encimpassword, status => $status_changed, checksum => $checksum
                    });
    }
  
    if (!$uid && $im_toggle)
    { if ($intermapper_groups || $intermapper_guest || $intermapper_external || $im_password )
      { my $checksum = md5_hex($name.$encimpassword.$intermapper_groups.$intermapper_guest.$intermapper_external);
        # TODO Checksum needs to be properly implemented
        $uid = "$source-$immaxid";
        $self->db->resultset('DsIntermapperUser')->create(
        { groups => $intermapper_groups, external => $intermapper_external, guest => $intermapper_guest, uid => $uid, source => $source,
          name => $name, password => $encimpassword, status => $status_created, id => $immaxid, checksum => $checksum
        });
      }
    }
  
    if ($uid && !$im_toggle)  
    { my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
      my $query_rs = $intermapper_rs->search({ uid => $uid });
      #$query_rs->delete;
      $query_rs->first->update({status => $status_deleted});
      delete($intermapperaccounts->{$uid});
      # TODO Add support for delete flag & remove hash delete
      $accounts->{$uid}{"intermapper"} = 0;
    }
  }

  for my $uid (@na_uid)
  { my ($source) = $uid =~ /^(.*?)\-X$/;
    my $na_toggle = $self->param("na_toggle_".$uid) || "0";
    my $na_userpassword = $self->param("na_userpassword_".$uid) || $password;
    my $encnapassword = encode_base64($self->cipher->encrypt($self->salt.$na_userpassword.$name));
    my $na_aaapassword = $self->param("na_aaapassword_".$uid) || $password;
    my $encnaaaapassword = encode_base64($self->cipher->encrypt($self->salt.$na_aaapassword.$name));
	my $na_emailaddress = $self->param("na_emailaddress_".$uid);
	my $na_comments = $self->param("na_comments_".$uid);
	my $na_distinguishedname = $self->param("na_distinguishedname_".$uid);
	my $na_allowfailover = $self->param("na_allowfailover_".$uid);
	my $na_timezone = $self->param("na_timezone_".$uid);
	my $na_firstname = $self->param("na_firstname_".$uid);
	my $na_useaaaloginforproxy = $self->param("na_useaaaloginforproxy_".$uid);
	my $na_privilegelevel = $self->param("na_privilegelevel_".$uid);
	my $na_passwordoption = $self->param("na_passwordoption_".$uid);
	my $na_aaausername = $self->param("na_aaausername_".$uid);
	my $na_status = $self->param("na_status_".$uid);
	my $na_ticketnumber = $self->param("na_ticketnumber_".$uid);
	my $na_lastname = $self->param("na_lastname_".$uid);

    # Temporary fix
    my $namax = $self->db->resultset('DsNaUser')->get_column('userid');
    my $namaxid = $namax->max;
    $namaxid++;
    if ($uid =~ /\-X$/) { $uid = ""; }

    if ($uid && $na_toggle)
    { $accounts->{$id}{"na"}{$uid}{"userpassword"} = $na_userpassword;
	  $accounts->{$id}{"na"}{$uid}{"aaapassword"} = $na_aaapassword;
	  $accounts->{$id}{"na"}{$uid}{"emailaddress"} = $na_emailaddress;
	  $accounts->{$id}{"na"}{$uid}{"comments"} = $na_comments;
	  $accounts->{$id}{"na"}{$uid}{"distinguishedname"} = $na_distinguishedname;
	  $accounts->{$id}{"na"}{$uid}{"allowfailover"} = $na_allowfailover;
	  $accounts->{$id}{"na"}{$uid}{"username"} = $name;
	  $accounts->{$id}{"na"}{$uid}{"timezone"} = $na_timezone;
	  $accounts->{$id}{"na"}{$uid}{"firstname"} = $na_firstname;
	  $accounts->{$id}{"na"}{$uid}{"useaaaloginforproxy"} = $na_useaaaloginforproxy;
	  $accounts->{$id}{"na"}{$uid}{"privilegelevel"} = $na_privilegelevel;
	  $accounts->{$id}{"na"}{$uid}{"passwordoption"} = $na_passwordoption;
	  $accounts->{$id}{"na"}{$uid}{"aaausername"} = $na_aaausername;
	  $accounts->{$id}{"na"}{$uid}{"status"} = $na_status;
	  $accounts->{$id}{"na"}{$uid}{"ticketnumber"} = $na_ticketnumber;
	  $accounts->{$id}{"na"}{$uid}{"lastname"} = $na_lastname;
      my $na_rs = $self->db->resultset('DsNaUser');
      my $query_rs = $na_rs->search({ uid => $uid });
      $encnapassword = $na_userpassword eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->userpassword : $encnapassword;
	  $encnaaaapassword = $na_aaapassword eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->aaapassword : $encnaaaapassword;

	  my $checksum = ""; # TODO Checksum needs to be implemented properly
      #my $checksum = md5_hex($name.$encacspassword.$acs_enabled.$acs_description.$acs_identitygroupname.$acs_enablepassword.$acs_passwordneverexpires.$acs_dateexceedsenabled.
      #                   $acs_dateexceeds.$acs_passwordtype);
	  # Need to store full datetime instead of date
      my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
      $mon++;
      $year += 1900;  
      my @months = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec); 
      my $lastmodified = "$months[$mon] $mday $year $hour:$min:$sec";
      my $created = "$months[$mon] $mday $year $hour:$min:$sec";
	  if ($query_rs)
      { $query_rs->first->update( 
		  { userpassword => $na_userpassword, emailaddress => $na_emailaddress, comments => $na_comments, aaapassword => $na_aaapassword,
			distinguishedname => $na_distinguishedname, allowfailover => $na_allowfailover, username => $name, timezone => $na_timezone,
            firstname => $na_firstname, useaaaloginforproxy => $na_useaaaloginforproxy, privilegelevel => $na_privilegelevel, lastname => $na_lastname,
			passwordoption => $na_passwordoption, aaausername => $na_aaausername, status => $na_status, ticketnumber => $na_ticketnumber,
			userid => $namaxid, na_status => $status_changed, 
			#lastmodified => $lastmodified
        });
	  }
	}
    if (!$uid && $na_toggle) # TODO: UID is, at this point, ALWAYS defined!!
    { if ($na_userpassword || $na_aaapassword || $na_emailaddress || $na_comments || $na_distinguishedname || $na_allowfailover 
	 || $na_timezone || $na_firstname || $na_useaaaloginforproxy || $na_privilegelevel || $na_lastname || $na_passwordoption || $na_aaausername
	 || $na_status || $na_ticketnumber)
     { my $checksum;# = md5_hex($name.$encisepassword.$ise_enabled.$ise_firstname.$ise_lastname.$ise_identitygroups.$ise_email.$ise_encenablepassword.
                    #  $ise_changepassword.$ise_expirydateenabled.$ise_expirydate.$ise_passwordidstore);
          $uid = "$source-$namaxid";
          # TODO Checksum needs to be implemented properly

		  # Need to store full datetime instead of date
      my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
      $mon++;
      $year += 1900;  
      my @months = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec); 
      my $lastmodified = "$months[$mon] $mday $year $hour:$min:$sec";
      my $created = "$months[$mon] $mday $year $hour:$min:$sec";
      $self->db->resultset('DsNaUser')->create(
        { userpassword => $na_userpassword, emailaddress => $na_emailaddress, comments => $na_comments, aaapassword => $na_aaapassword,
		  distinguishedname => $na_distinguishedname, allowfailover => $na_allowfailover, username => $name, timezone => $na_timezone,
		  firstname => $na_firstname, useaaaloginforproxy => $na_useaaaloginforproxy, privilegelevel => $na_privilegelevel, lastname => $na_lastname,
		  passwordoption => $na_passwordoption, aaausername => $na_aaausername, status => $na_status, ticketnumber => $na_ticketnumber,
		  userid => $namaxid, na_status => $status_created, source=> $source, uid => $uid, #lastmodified => $lastmodified, created => $created,
        });
     } 
  }
    if ($uid && !$na_toggle)
    { my $na_rs = $self->db->resultset('DsNaUser');
      my $query_rs = $na_rs->search({ uid => $uid });
      # $query_rs->delete;
      # TODO Add support for delete flag & remove hash delete
      delete($naaccounts->{$uid});
      $query_rs->first->update({na_status => $status_deleted});
      $accounts->{$uid}{"na"} = 0;
    }
  }

  $self->consolidate();
  
  $accounts->{$id}{"name"} = $name;
  $accounts->{$id}{"password"} = $encpassword if $password;
  $accounts->{$id}{"authentication"} = $authentication;

  my $account_rs = $self->db->resultset('Account');
  my $query_rs = $account_rs->search({ name => $id }); 
  if ($query_rs->first)
  { if ($password)
    { $query_rs->update({ name => $name, password => $encpassword, authentication => $authentication }); 
    }
    else
    { $query_rs->update({ name => $name, authentication => $authentication }); 
    }
  } else
  { # Temporary fix - Implement UID generation too! TODO
    my $amax = $self->db->resultset('Account')->get_column('Id');
    my $amaxid = $amax->max;
    $amaxid++;
	my %account = (name => $id,
            password => $encpassword,
            id => $amaxid,
            uid => $amaxid, # TODO: This may need to be fixed
            authentication => $authentication,
			);
    if ($password eq "PASSWORDHASBEENCHANGED!!") { delete($account{"password"}); }
    $self->db->resultset('Account')->create(\%account);
  }
  $self->redirect_to("/accounts/$id");
}

sub delete { # DELETE /accounts/123 - delete a account - Also multi-selected IDs from listing!
  my $self = shift;
  $self->redirect_to('/login/') && return if !$self->session('logged_in');  
  my $uid = $self->param("uid");
  my @extraid = @ { $self->every_param("extraid") };
  unshift(@extraid, $uid);
  for my $uid (@extraid)
  { delete($accounts->{$uid});
    my $account_rs = $self->db->resultset('Account');
    my $query_rs = $account_rs->search({ name => $uid }); # BUG again??!?! See a few lines up!
    if ($query_rs)
    { $query_rs->delete; # TODO Implement delete flag and remove DB delete
    }
    
    my $ise_rs = $self->db->resultset('DsIseInternaluser');
    $query_rs = $ise_rs->search({ name => $uid });
    if ($query_rs)
    { $query_rs->delete; # TODO Implement delete flag and remove DB delete
    }
    delete($iseaccounts->{$uid}); # TODO Implement delete flag and remove DB delete
      
    my $acs_rs = $self->db->resultset('DsAcsUser');
    $query_rs = $acs_rs->search({ name => $uid }); # BUG again?!?!?! See a few lines up!
    if ($query_rs)
    { $query_rs->delete; # TODO Implement delete flag and remove DB delete
    }
    delete($acsaccounts->{$uid}); # TODO Implement delete flag and remove DB delete
  
    my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
    $query_rs = $intermapper_rs->search({ name => $uid }); # BUG again ?!?!?!? See a few lines up!
    if ($query_rs)
    { $query_rs->delete; # TODO Implement delete flag and remove DB delete
    }
    delete($intermapperaccounts->{$uid}); # TODO Implement delete flag and remove DB delete

    my $na_rs = $self->db->resultset('DsNaUser');
    $query_rs = $na_rs->search({ name => $uid }); # BUG again ?!?!?!? See a few lines up!
    if ($query_rs)
    { $query_rs->delete; # TODO Implement delete flag and remove DB delete
    }
    delete($naaccounts->{$uid}); # TODO Implement delete flag and remove DB delete

  }
  $self->redirect_to("/accounts/");
}

sub consolidate {
  my $self = shift;
  # Consolidate based on account login..
  $self->redirect_to('/login/') && return if !$self->session('logged_in');
  my $sources_rs = $self->db->resultset('DsSource');
  my $query_rs = $sources_rs->search;
  my %sources = ();

  while (my $source = $query_rs->next)
  { $sources{$source->id} = $source;
  }

  $accounts = {};
  my $account_rs = $self->db->resultset('Account');
  $query_rs = $account_rs->search;
  while (my $account = $query_rs->next)
  { $accounts->{$account->name}{"name"} = $account->name if $account->name;
  }
  
  my $acs_rs = $self->db->resultset('DsAcsUser');
  $query_rs = $acs_rs->search;
  while (my $account = $query_rs->next)
  { $acsaccounts->{$account->name}{$account->uid} = $account if $account->name;
    for my $source (keys %sources)
    { $accounts->{$account->name}{"stub_ise"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ISE";
      $accounts->{$account->name}{"stub_intermapper" }{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "Intermapper";
	  $accounts->{$account->name}{"stub_na" }{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "NA";
    }
  }
  
  my $ise_rs = $self->db->resultset('DsIseInternaluser');
  $query_rs = $ise_rs->search;
  while (my $account = $query_rs->next)
  { $iseaccounts->{$account->name}{$account->uid} = $account if $account->name;
    for my $source (keys %sources)
    { $accounts->{$account->name}{"stub_acs"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ACS";
      $accounts->{$account->name}{"stub_intermapper" }{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "Intermapper";
	  $accounts->{$account->name}{"stub_na" }{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "NA";
    }
  }

  my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
  $query_rs = $intermapper_rs->search;
  while (my $account = $query_rs->next)
  { $intermapperaccounts->{$account->name}{$account->uid} = $account if $account->name;
    for my $source (keys %sources)
    { $accounts->{$account->name}{"stub_ise"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ISE";
      $accounts->{$account->name}{"stub_acs"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ACS";
	  $accounts->{$account->name}{"stub_na" }{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "NA";
    }
  }

  my $na_rs = $self->db->resultset('DsNaUser');
  $query_rs = $na_rs->search;
  while (my $account = $query_rs->next)
  { $naaccounts->{$account->username}{$account->uid} = $account if $account->username;
    for my $source (keys %sources)
    { $accounts->{$account->username}{"stub_ise"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ISE";
      $accounts->{$account->username}{"stub_acs"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ACS";
      $accounts->{$account->username}{"stub_intermapper"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "Intermapper";	  
    }
  }

  my %acs = ();
  my %intermapper = ();
  my %ise = ();
  my %na = ();
  for my $db ($acsaccounts, $iseaccounts, $intermapperaccounts, $naaccounts)
  { for my $key (keys %{$db})
    { for my $uid (keys %{$db->{$key}}) # UIDs = Users
      { if (ref($db->{$key}{$uid}) eq "NG::Schema::Result::DsAcsUser")
        { if (!$accounts->{$db->{$key}{$uid}->name}{"name"})
          { $accounts->{$db->{$key}{$uid}->name}{"name"} = $db->{$key}{$uid}->name;
            $accounts->{$db->{$key}{$uid}->name}{"password"} = $db->{$key}{$uid}->password || "";
          }
          delete($accounts->{$db->{$key}{$uid}->name}{"stub_acs"}{$db->{$key}{$uid}->source->id."-X"});
          $accounts->{$db->{$key}{$uid}->name}{"password"} ||= "";
          #$accounts->{$db->{$key}{$uid}->name}{"acs"} = 1;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"status"} = 1;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"description"} = $db->{$key}{$uid}->description;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"identitygroupname"} = $db->{$key}{$uid}->identitygroupname->name;
          # Table relationship to ds_acs_identitygroup
          # THIS one is a strange fix for the way DBIX::Class handles has_many with singular and plural names - Tricky part is for ISE more than for ACS!
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"enabled"} = bool($db->{$key}{$uid}->enabled);
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"enablepassword"} = $db->{$key}{$uid}->enablepassword;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"passwordneverexpires"} = bool($db->{$key}{$uid}->passwordneverexpires);
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"password"} = $db->{$key}{$uid}->password;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"passwordtype"} = $db->{$key}{$uid}->passwordtype;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"dateexceeds"} = $db->{$key}{$uid}->dateexceeds;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"dateexceedsenabled"} = bool($db->{$key}{$uid}->dateexceedsenabled);
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"id"} = $db->{$key}{$uid}->id;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"uid"} = $db->{$key}{$uid}->uid;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"source"} = $db->{$key}{$uid}->source;
          $acs{$db->{$key}{$uid}->name}  = 1;
          
        }
        if (ref($db->{$key}{$uid}) eq "NG::Schema::Result::DsIntermapperUser")
        { if (!$accounts->{$db->{$key}{$uid}->name}{"name"})
          { $accounts->{$db->{$key}{$uid}->name}{"name"} = $db->{$key}{$uid}->name;
            $accounts->{$db->{$key}{$uid}->name}{"password"} = $db->{$key}{$uid}->password || "";
          }
          $accounts->{$db->{$key}{$uid}->name}{"password"} ||= "";
          #$accounts->{$db->{$key}->name}{"intermapper"} = 1;
          delete($accounts->{$db->{$key}{$uid}->name}{"stub_intermapper"}{$db->{$key}{$uid}->source->id."-X"});
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"status"} = 1;
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"groups"} = $db->{$key}{$uid}->groups || "";
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"external"} = bool($db->{$key}{$uid}->external);
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"guest"} = $db->{$key}{$uid}->guest;
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"uid"} = $db->{$key}{$uid}->uid;
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"id"} = $db->{$key}{$uid}->id;
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"source"} = $db->{$key}{$uid}->source;
          $intermapper{$db->{$key}{$uid}->name} = 1;
          
          #$accounts->{$db->{$key}{$uid}->name}{"stub_im"}{$uid}{"source"} = $db->{$key}{$uid}->source;
        }
        if (ref($db->{$key}{$uid}) eq "NG::Schema::Result::DsIseInternaluser")
        { if (!$accounts->{$db->{$key}{$uid}->name}{"name"})
          { $accounts->{$db->{$key}{$uid}->name}{"name"} = $db->{$key}{$uid}->name;
            $accounts->{$db->{$key}{$uid}->name}{"password"} = $db->{$key}{$uid}->password;
          }
          delete($accounts->{$db->{$key}{$uid}->name}{"stub_ise"}{$db->{$key}{$uid}->source->id."-X"});
          $accounts->{$db->{$key}{$uid}->name}{"password"} ||= "";
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"status"} = 1;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"email"} = $db->{$key}{$uid}->email; 
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"firstname"} = $db->{$key}{$uid}->firstname;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"lastname"} = $db->{$key}{$uid}->lastname;        
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"identitygroups"} = $db->{$key}{$uid}->identitygroup->name;
          # Table relationship to ds_ise_identitygroup
          # THIS one is a strange fix for the way DBIX::Class handles has_many with singular and plural names!
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"changepassword"} = bool($db->{$key}{$uid}->changepassword);
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"enabled"} = bool($db->{$key}{$uid}->enabled);
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"enablepassword"} = $db->{$key}{$uid}->enablepassword;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"password"} = $db->{$key}{$uid}->password;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"passwordidstore"} = $db->{$key}{$uid}->passwordidstore;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"expirydate"} = $db->{$key}{$uid}->expirydate;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"expirydateenabled"} = bool($db->{$key}{$uid}->expirydateenabled);
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"id"} = $db->{$key}{$uid}->id;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"uid"} = $db->{$key}{$uid}->uid;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"source"} = $db->{$key}{$uid}->source;
          $ise{$db->{$key}{$uid}->name} = 1;
        }
		if (ref($db->{$key}{$uid}) eq "NG::Schema::Result::DsNaUser")
        { if (!$accounts->{$db->{$key}{$uid}->username}{"name"})
          { $accounts->{$db->{$key}{$uid}->username}{"name"} = $db->{$key}{$uid}->username;
            $accounts->{$db->{$key}{$uid}->username}{"password"} = $db->{$key}{$uid}->userpassword;
          }
          delete($accounts->{$db->{$key}{$uid}->username}{"stub_na"}{$db->{$key}{$uid}->source->id."-X"});
          $accounts->{$db->{$key}{$uid}->username}{"password"} ||= "";
          $accounts->{$db->{$key}{$uid}->username}{"na_status"} = 1;
		  $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"distinguishedname"} = $db->{$key}{$uid}->distinguishedname; 
		  $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"aaausername"} = $db->{$key}{$uid}->aaausername;
		  $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"aaapassword"} = $db->{$key}{$uid}->aaapassword;
		  $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"userpassword"} = $db->{$key}{$uid}->userpassword;
		  $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"useaaaloginforproxy"} = bool($db->{$key}{$uid}->useaaaloginforproxy);
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"requireduser"} = bool($db->{$key}{$uid}->requireduser);
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"allowfailover"} = bool($db->{$key}{$uid}->allowfailover);
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"status"} = $db->{$key}{$uid}->status;
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"privilegelevel"} = $db->{$key}{$uid}->privilegelevel;
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"passwordoption"} = $db->{$key}{$uid}->passwordoption;
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"timezone"} = $db->{$key}{$uid}->timezone;
		  $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"ticketnumber"} = $db->{$key}{$uid}->ticketnumber;
		  $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"comments"} = $db->{$key}{$uid}->comments;
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"emailaddress"} = $db->{$key}{$uid}->emailaddress; 
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"firstname"} = $db->{$key}{$uid}->firstname;
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"lastname"} = $db->{$key}{$uid}->lastname;        
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"id"} = $db->{$key}{$uid}->userid;
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"uid"} = $db->{$key}{$uid}->uid;
          $accounts->{$db->{$key}{$uid}->username}{"na"}{$uid}{"source"} = $db->{$key}{$uid}->source;
          $na{$db->{$key}{$uid}->username} = 1;
        }
      }

      # TODO: FIX THIS AND USE SEPARATE UID TO IDENTIFY CORRECT DATA SOURCE
      for my $source (keys %sources)
      { if (ref($sources{$source}) eq "Net::Cisco::ACS")
        { #$acs->users(users => \%acs);
        }
        if (ref($sources{$source}) eq "Net::Cisco::ISE")
        { #$ise->internalusers(internalusers => \%ise);
        }
        if (ref($sources{$source}) eq "Net::Intermapper")
        { #$intermapper->users(\%intermapper);
        }
        if (ref($sources{$source}) eq "Net::HP::NA")
        { #$na->users(\%na);
        }

      }      
    }
  }
}

sub bool
{ return " checked" if $_[0];
}

# This is used by mapping!! 
sub synchronize # REVIEW!!
{ my $self = shift;
  $self->redirect_to('/login/') && return if !$self->session('logged_in'); 
  my $filter = lc($self->param("filter"));
  my @mappings = ();
  my @rules = ();
  my $syncrules_rs = $self->db->resultset('Syncrule');  
  my $mapping_rs = $self->db->resultset('Mapping');
  my $query_rs = $syncrules_rs->search({},  { order_by => "priority" });
  while (my $rule = $query_rs->next)
  { push(@rules, { source_ds => $rule->source_ds, destination_ds => $rule->destination_ds, priority => $rule->priority, id => $rule->id });
  }
  
  # DBIx::Class is working as designed but obviously some of the fields with S at the end are NOT PLURAL..
  # I DON'T WANT TO BREAK ANYTHING ELSE BUT REMEMBER TO CHECK THE FIELD NAMES AND USE WITHOUT S AT THE END IF NEEDED!!
  $query_rs = $mapping_rs->search({ source_table => "Users" });
  while (my $mapping = $query_rs->next)
  { my ($source_ds, $source_table, $source_field, $destination_ds, $destination_table, $destination_field, $create, $append, $overwrite) =
   ($mapping->source_d, $mapping->source_table, $mapping->source_field, $mapping->destination_d, $mapping->destination_table,
    $mapping->destination_field, $mapping->createflag, $mapping->appendflag, $mapping->overwriteflag);
    push(@mappings,
         { source_ds => $source_ds, source_table => $source_table, source_field => $source_field,
           destination_ds => $destination_ds, destination_table => $destination_table, destination_field => $destination_field,
           create => $create, append => $append, overwrite => $overwrite
         });
  }

  for my $rule (@rules)
  { my $acs_rs = $self->db->resultset('DsAcsUser');
    $query_rs = $acs_rs->search;
    while (my $account = $query_rs->next)
    { my %account = $account->get_columns;
      for my $map (@mappings)
      { if  ($map->{source_ds}->type->shortname eq "ACS")  # ACS
        { if (my ($sfield) = $map->{source_field} =~ /^dynamic: (.*)$/) # Source field dynamic - Probably only for name
          { if (my ($dfield, $dvalue) = $map->{destination_field} =~ /^dynamic: (\S*)\s?(\S*)$/) # Destination field dynamic - Probably only for name
            { # ACS to Intermapper
              $sfield =~ s/[\r\n]//g; $dfield =~ s/[\r\n]//g;
              if ($map->{destination_ds}->type->shortname eq "Intermapper")
              { my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
                my %criteria = (); #($dfield => $account{$sfield});
                $criteria{"name"} = $account{"name"};
                my $im_rs = $intermapper_rs->search({ %criteria }); # find all IM records with name matching sourcd DS, create if needed
                my $empty = 1;
                while (my $imaccount = $im_rs->next)
                { if ($map->{"overwrite"} eq "1") # APPEND FUNCTIONALITY TO DO!!
                  { if (!$dvalue)
                    { $imaccount->update({ $dfield => $account{"$sfield"} }) ; } else # TODO Update status and checksum fields
                    { $dvalue =~ s/\"//g; $imaccount->update({ $dfield => $dvalue }) ; }
                    # TODO Update status and checksum fields
                  }
                  $empty = 0;
                }
                # Temporary fix
                my @chars = ("A".."Z", "a".."z","0".."9");
                my $immaxid;
                $immaxid .= $chars[rand @chars] for 1..8;

                if ($empty)  # No records matching criteria already exist - insert!
                { if ($map->{"create"} eq "1") 
                  { $self->db->resultset('DsIntermapperUser')->create({
                    uid => $map->{destination_ds}->id."-".$immaxid, id => $immaxid, source => $map->{destination_ds}->id, $dfield => $account{$sfield} });
                    # TODO Update status and checksum fields
                  }
                }
              }
              
              # ACS to ISE
            
              if ($map->{destination_ds}->type->shortname eq "ISE")
              { my $ise_rs = $self->db->resultset('DsIseInternaluser');
                my %criteria = (); #($dfield => $account{$sfield});
                # if ($sfield ne "name") # Onlu use NAME field!!
                $criteria{"name"} = $account{"name"};
                my $cise_rs = $ise_rs->search({ %criteria });
                my $empty = 1;
                while (my $iseaccount = $cise_rs->next)
                { if ($map->{"overwrite"} eq "1") # APPEND FUNCTIONALITY TO DO!!
                  { if (!$dvalue)
                   { $iseaccount->update({ $dfield => $account{"$sfield"} }) ; } else # TODO Update status and checksum fields
                   { $dvalue =~ s/\"//g;
                     $iseaccount->update({ $dfield => $dvalue }) ;
                     # TODO Update status and checksum fields
                   } 
                  }
                  $empty = 0;
                }
                if ($empty) 
                { if ($map->{"create"} eq "1")
                  { # Temporary fix
                    my $isemax = $self->db->resultset('DsIseInternaluser')->get_column('Id');
                    my $isemaxid = $isemax->max;
                    $isemaxid++;
                    $self->db->resultset('DsIseInternaluser')->create({
                    uid => $map->{destination_ds}->id."-".$isemaxid, id => $isemaxid, source => $map->{destination_ds}->id, "name" => $account{"name"},
                    $dfield => $account{"$sfield"}
                    }); # TODO Update status and checksum fields
                  }
                }
              }
              
              if ($map->{destination_ds}->type->shortname eq "ACS")
              { my $acs_rs = $self->db->resultset('DsAcsUser');
                my %criteria = (); #($dfield => $account{$sfield});
                # if ($sfield ne "name") # Only use NAME field!!
                $criteria{"name"} = $account{"name"}; 
                my $cacs_rs = $acs_rs->search({ %criteria });
                my $empty = 1;
                while (my $acsaccount = $cacs_rs->next)
                { if ($map->{"overwrite"} eq "1") # APPEND FUNCTIONALITY TO DO!!
                  { if (!$dvalue)
                   { $acsaccount->update({ $dfield => $account{"$sfield"} }) ; } else # TODO Update status and checksum fields
                   { $dvalue =~ s/\"//g; $acsaccount->update({ $dfield => $dvalue }) ;
                    # TODO Update status and checksum fields
                   } 
                  }
                  $empty = 0;
                }
                if ($empty) 
                { if ($map->{"create"} eq "1")
                  { $self->db->resultset('DsAcsUser')->create({ $dfield => $account{"$sfield"} });
                   # TODO Update status and checksum fields
                  }
                }
              }
            }
          } # source_field and destination_field dynamic
                
          if (my ($sfield, $svalue) = $map->{source_field} =~ /^static: (.*?) \"(.*?)\"$/) # Source field static - Probably only for name
          { if (my ($dfield,$dvalue) = $map->{destination_field} =~ /^static: (.*?) \"(.*?)\"$/) # Destination field static - Probably only for name
            { # ACS to Intermapper
              if ($map->{destination_ds}->type->shortname eq "Intermapper")
              { if ($svalue && $account{"$sfield"} && $account{"$sfield"} eq $svalue)
                { my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
                  my %criteria = ("name" => $account{"name"}); # Find record in IM db matchin name
                  my $im_rs = $intermapper_rs->search({ %criteria });
                  if ($im_rs) # Records matching criteria already exist - only update!
                  { while (my $imaccount = $im_rs->next)
                    { if ($map->{"append"} eq "1")
                      { $dvalue = $dvalue && $imaccount->{$dfield} ? $imaccount->{$dfield}.$dvalue : $imaccount->{$dfield};
                        $imaccount->update({ $dfield => $dvalue }) ;
                        # TODO Update status and checksum fields
                      }
                      if ($map->{"overwrite"} eq "1")
                      { $imaccount->update({ $dfield => $dvalue }) ;
                       # TODO Update status and checksum fields
                      }
                    } 
                  } else  # No records matching criteria already exist - insert!
                  { if ($map->{"create"} eq "1")
                    { # Temporary fix
                      my @chars = ("A".."Z", "a".."z","0".."9");
                      my $immaxid;
                      $immaxid .= $chars[rand @chars] for 1..8;
                      $self->db->resultset('DsIntermapperUser')->create(
                       { uid => $map->{destination_ds}->id."-".$immaxid, id => $immaxid, source => $map->{destination_ds}->id,
                         "name" => $account{"name"}, $dfield => $dvalue });
                      # TODO Update status and checksum fields
                    }
                  }
                }
              }

              # ACS to ISE
              if ($map->{destination_ds}->type->shortname eq "ISE")
              { my $svfield = $account{"$sfield"} || "";
                #if ($svalue eq $svfield)
                { my $ise_rs = $self->db->resultset('DsIseInternaluser');
                  my %criteria = ("name" => $account{"name"}); # Find record in ISE db matchin name
                  my $cise_rs = $ise_rs->search({ %criteria });
                  if ($cise_rs) # Records matching criteria already exist - only update!
                  { while (my $iseaccount = $cise_rs->next)
                    { if ($map->{"append"} eq "1")
                      { $dvalue ||= "";
                        $iseaccount->{$dfield} ||= "";
                        $iseaccount->update({ $dfield => $iseaccount->{$dfield}.$dvalue }) ;
                        # TODO Update status and checksum fields
                      }
                      if ($map->{"overwrite"} eq "1")
                      { my $ise_rs = $self->db->resultset('DsIseIdentitygroup');
                        my %criteria = ("name" => $dvalue); 
                        my $cise_rs = $ise_rs->search({ %criteria });
                        $dvalue = $cise_rs->first->uid;
                        $iseaccount->update({ $dfield => $dvalue }) ;
                        # TODO Update status and checksum fields
                      }
                    }
                  } else  # No records matching criteria already exist - insert!
                  { if ($map->{"create"} eq "1")
                    { # Temporary fix
                      my $isemax = $self->db->resultset('DsIseInternaluser')->get_column('Id');
                      my $isemaxid = $isemax->max;
                      $isemaxid++;
                      $self->db->resultset('DsIseInternaluser')->create({
                      uid => $map->{destination_ds}->id."-".$isemaxid, id => $isemaxid, source => $map->{destination_ds}->id, "name" => $account{"name"},
                      $dfield => $dvalue
                    });
                      # TODO Update status and checksum fields
                    }
                  }
                }
              }
            }
          }  # source_field and destination_field static
        
        } # source_ds = ACS
      }
    }
  }
  if ($filter)
  { $self->redirect_to("/accounts/?filter=$filter");
  } else
  { $self->redirect_to("/accounts/"); }
}

1;
