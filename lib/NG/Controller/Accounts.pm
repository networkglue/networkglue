package NG::Controller::Accounts;
use Mojo::Base 'Mojolicious::Controller';
use Data::Dumper;
use Net::Cisco::ACS::User;
use Net::Cisco::ISE::InternalUser;
use Net::Intermapper::User;

use Digest::MD5 qw(md5_hex);
use MIME::Base64;

my $accounts = {};
my $acsaccounts = {};
my $iseaccounts = {};
my $iseaccounts_ref = [];
my $intermapperaccounts = {};

my $status_clean = 0;
my $status_changed = 1; # NG Entry Changed
my $status_created = 2; # NG Entry Created
my $status_deleted = 3; # NG Entry Deleted
my $status_imported = 4; # NG Entry Imported from API - new entry
my $status_synchronized = 5; # NG Entry Synchronized from API - existing entry

sub new_form { # GET /accounts/new - form to create a account   
  my $self = shift;
  $self->redirect_to('/login/') if !$self->session('logged_in');
  my $filter = "";
  $self->stash(filter => $filter);
  $self->stash(items => $self->items);  

  my $acs_rs = $self->db->resultset('DsAcsIdentitygroup');
  my $query_rs = $acs_rs->search;
  my $acsidgroups = {};
  while (my $accountgroup = $query_rs->next)
  { $acsidgroups->{$accountgroup->uid} = $accountgroup->name; }
  $self->stash(acsidgroups => $acsidgroups);

  my $ise_rs = $self->db->resultset('DsIseIdentitygroup');
  $query_rs = $ise_rs->search;
  my $iseidgroups = {};
  while (my $accountgroup = $query_rs->next)
  { $iseidgroups->{$accountgroup->uid} = $accountgroup->name; }
  $self->stash(iseidgroups => $iseidgroups);

  my $auth_rs = $self->db->resultset('Authentication');
  $query_rs = $auth_rs->search;
  my $authgroups = { "0" => { "hostname" => "Local", "type" => "-" } };
  while (my $authgroup = $query_rs->next)
  { $authgroups->{$authgroup->id}{"hostname"} = $authgroup->hostname;
    $authgroups->{$authgroup->id}{"type"} = $authgroup->type;
  }
  $self->stash(authgroups => $authgroups);
  
  my $im_rs = $self->db->resultset('DsIntermapperUser');
  $query_rs = $im_rs->search;
  my $imidgroups = {};
  while (my $accountgroup = $query_rs->next)
  { my (@groups) = split(/\,/,$accountgroup->groups);
    for my $name (@groups)
    { $imidgroups->{$name}{"name"} = $name;
    }
  } 
  my $username = $self->session('username');
  $self->stash(username => $username);

  $self->stash(imidgroups => $imidgroups); 
  $self->render('accounts/create', layout => 'accounts');
}

# This action will render a template
sub show { # GET /accounts/123 - show account with id 123
  my $self = shift;
  $self->redirect_to('/login/') if !$self->session('logged_in');
  my $id = $self->param("id"); # Param ID is generated by  Mojox-Scaffold
  my $filter = $self->param('filter');
  $self->consolidate() unless keys %{ $accounts };  
  my $account = $accounts->{$id};
  $self->stash(account => $account);
  $self->stash(iseaccounts => $iseaccounts_ref);
  my $filterheader = "";
  my $auth_rs = $self->db->resultset('Authentication');
  my $query_rs = $auth_rs->search;
  my $authgroups = { "0" => { "hostname" => "Local", "type" => "-" } };
  
  while (my $authgroup = $query_rs->next)
  { $authgroups->{$authgroup->id}{"hostname"} = $authgroup->hostname;
    $authgroups->{$authgroup->id}{"type"} = $authgroup->type;
    $authgroups->{$authgroup->id}{"selected"} = " selected" if $account->{"authentication"} && $account->{"authentication"} eq $authgroup->id;
  }
  $authgroups->{"0"}{"selected"} = " selected" if $account->{"authentication"} && $account->{"authentication"} eq "0";  
  $self->stash(authgroups => $authgroups);

  my $sources_rs = $self->db->resultset('DsSource');
  $query_rs = $sources_rs->search;
  my $sources = {};
  
  while (my $source = $query_rs->next)
  { $sources->{$source->id} = $source->type->shortname;
  }

  my %acs_toggle = ();
  my %ise_toggle = ();
  my %im_toggle = ();
  
  for my $target (sort keys %{$sources})
  { if ($sources->{$target} eq "ACS")
    { my $acs_rs = $self->db->resultset('DsAcsIdentitygroup');
      my $query_rs = $acs_rs->search;
      my $acsidgroups = {};

      while (my $accountgroup = $query_rs->next)
     { $acsidgroups->{$accountgroup->uid}{"name"} = $accountgroup->name;
       $acsidgroups->{$accountgroup->uid}{"selected"} = " selected" if $account->{"acs_identitygroupname"} && $account->{"acs_identitygroupname"} eq $accountgroup->name;
     }
     $self->stash(acsidgroups => $acsidgroups);
     #my $acs_toggle = $account->{"acs_status"} && $account->{"acs_status"} ne "fa-close text-danger" ? " checked" : "";
     $acs_toggle{$target} = $account->{"acs"} && $account->{"acs"} ne "fa-close text-danger" ? " checked" : "";
    }
    if ($sources->{$target} eq "ISE")
    { my $ise_rs = $self->db->resultset('DsIseIdentitygroup');
      $query_rs = $ise_rs->search;
      my $iseidgroups = {};

      while (my $accountgroup = $query_rs->next)
      { $iseidgroups->{$accountgroup->uid}{"name"} = $accountgroup->name;
        $iseidgroups->{$accountgroup->uid}{"selected"} = " selected" if $account->{"ise_identitygroups"} && $account->{"ise_identitygroups"} eq $accountgroup->uid;
      }
      $self->stash(iseidgroups => $iseidgroups);
      #my $ise_toggle = $account->{"ise_status"} && $account->{"ise_status"} ne "fa-close text-danger" ? " checked" : "";
      $ise_toggle{$target} = $account->{"ise_status"} && $account->{"ise_status"} ne "fa-close text-danger" ? " checked" : "";
    }
    
    if ($sources->{$target} eq "Intermapper")
    { my $im_rs = $self->db->resultset('DsIntermapperUser');
      $query_rs = $im_rs->search;
      my $imidgroups = {};

      while (my $accountgroup = $query_rs->next)
      { my (@groups) = split(/\,/,$accountgroup->groups);
        for my $name (@groups)
        { $imidgroups->{$name}{"name"} = $name;
          $imidgroups->{$name}{"selected"} = " selected" if $account->{"intermapper_groups"} && $account->{"intermapper_groups"} eq $name;
        }
      } 
      $self->stash(imidgroups => $imidgroups);
      #my $im_toggle = $account->{"intermapper_status"} && $account->{"intermapper_status"} ne "fa-close text-danger" ? " checked" : "";
      $im_toggle{$target} = $account->{"intermapper_status"} && $account->{"intermapper_status"} ne "fa-close text-danger" ? " checked" : "";
    }
  }
  #$self->app->log->debug(Dumper \%acs_toggle);
  $self->stash(acs_toggle => \%acs_toggle);
  $self->stash(ise_toggle => \%ise_toggle);
  $self->stash(im_toggle => \%im_toggle);
  
  my $username = $self->session('username');
  $self->stash(username => $username);
  $self->stash(items => $self->items);
  $self->stash(filterheader => $filterheader);
  $filter = "?filter=$filter" if $filter;
  $self->stash(filter => $filter);
  $self->render('accounts/detail', layout => 'accounts');
}

sub edit_form { # GET /accounts/123/edit - form to update a account
}

# This action will render a template
sub index { # GET /accounts - list of all accounts
  my $self = shift;
  $self->redirect_to('/login/') if !$self->session('logged_in');
  $self->consolidate();
  my $filter = $self->param('filter');
  my %accounts = %{ $accounts };
  my %status = {};
  for my $account (keys %accounts)
  { #for my $key (qw(acs ise ad ldap nagios hpna intermapper cacti))
    for my $key (qw(acs ise intermapper))
    { #$accounts->{$account}{"$key"} = ($accounts->{$account}{"$key"} && $accounts->{$account}{"$key"} ne "fa-close text-danger") ? "fa-check text-success" : "fa-close text-danger";
      $status{$account}{$key} = ($accounts->{$account}{"$key"} && $accounts->{$account}{"$key"} ne "fa-close text-danger") ? "fa-check text-success" : "fa-close text-danger";
    }
  }
  $self->stash(accounts => $accounts);
  $self->stash(status => \%status);
  my $filterheader = "";
  if ($filter)
  { my %accounts = %{ $accounts };
    my @keys = grep { $accounts->{$_}{$filter} ne "fa-close text-danger" } keys %accounts;
    my %filteraccounts = ();
    @filteraccounts{@keys} = @accounts{@keys};
    $self->stash(accounts => \%filteraccounts);
    $filterheader = "$self->items->{$filter} Accounts - ";
  } else
  {  $self->stash(accounts => $accounts); }
  my $username = $self->session('username');
  $self->stash(username => $username);

  $self->stash(items => $self->items);
  $self->stash(filterheader => $filterheader);
  $filter = "?filter=$filter" if $filter;

  $self->stash(filter => $filter);
  $self->render('accounts/index', layout => 'accounts');
}

sub create { # POST /accounts - create new account
  my $self = shift;
  $self->redirect_to('/login/') if !$self->session('logged_in');  
  my $name = $self->param("name");
  my $password = $self->param("password");
  my $authentication = $self->param("authentication");  

  # Temporary fix - Implement UID generation too! TODO
  my $amax = $self->db->resultset('Account')->get_column('Id');
  my $amaxid = $amax->max;
  $amaxid++;

  $self->db->resultset('Account')->create({
            name => $name,
            password => $password,
            id => $amaxid,
            uid => $amaxid, # TODO: This may need to be fixed
            authentication => $authentication,
        });

  my $acs_rs = $self->db->resultset('DsAcsUser');
  my $query_rs = $acs_rs->search({ name => "__default" });
  my $defaultacs = $query_rs->first;

  my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
  $query_rs = $intermapper_rs->search({ name => "__default" });
  my $defaultintermapper = $query_rs->first;

  my $ise_rs = $self->db->resultset('DsIseInternaluser');
  $query_rs = $ise_rs->search({ name => "__default" });
  my $defaultise = $query_rs->first;

  # Temporary fix
  my $immax = $self->db->resultset('DsIntermapperUser')->get_column('Id');
  my $immaxid = $immax->max;
  $immaxid++;
  
  # Temporary fix
  my $acsmax = $self->db->resultset('DsAcsUser')->get_column('Id');
  my $acsmaxid = $acsmax->max;
  $acsmaxid++;
  
  # Temporary fix
  my $isemax = $self->db->resultset('DsIseInternaluser')->get_column('Id');
  my $isemaxid = $isemax->max;
  $isemaxid++;

  my $acs_toggle = $self->param("acs_toggle") || "0";
  my $ise_toggle = $self->param("ise_toggle") || "0";
  my $im_toggle = $self->param("im_toggle") || "0";
  
  my $acs_password = $self->param("acs_password") || $password;
  my $acs_enabled = $self->param("acs_enabled");
  my $acs_description = $self->param("acs_description");
  my $acs_identitygroupname = $self->param("acs_identitygroupname");
  my $acs_enablepassword = $self->param("acs_enablepassword");
  my $acs_passwordneverexpires = $self->param("acs_passwordneverexpires");
  my $acs_dateexceedsenabled = $self->param("acs_dateexceedsenabled");
  my $acs_dateexceeds = $self->param("acs_dateexceeds");
  my $acs_passwordtype = $self->param("acs_passwordtype");
  
  my $encpassword = encode_base64($self->cipher->encrypt($self->salt.$password.$name));
  my $encacspassword = encode_base64($self->cipher->encrypt($self->salt.$acs_password.$name));
    
  my $auth_rs = $self->db->resultset('Authentication');
  $query_rs = $acs_rs->search;
  my $authgroups = { "0" => { "hostname" => "Local", "type" => '-' } };
  
  while (my $authgroup = $query_rs->next)
  { $authgroups->{$authgroup->id}{"name"} = $authgroup->hostname;
    $authgroups->{$authgroup->id}{"type"} = $authgroup->type;
  }
  $authgroups->{"0"}{"selected"} = " selected";  
  $self->stash(authgroups => $authgroups);
    
  # Need to store full datetime instead of date
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
  $mon++;
  $year += 1900;  
  my $created = "$mday/$mon/$year";
  my $lastmodified = "$mday/$mon/$year";
  
  my $sources_rs = $self->db->resultset('DsSource');
  $query_rs = $sources_rs->search;
  my $sources = {};

  while (my $source = $query_rs->next)
  { $sources->{$source->type->id} = $source->type->shortname;
  }
  
  if ($defaultacs)
  { $acs_enabled ||= $defaultacs->enabled;  
    $acs_description ||= $defaultacs->description;
    $acs_identitygroupname ||= $defaultacs->identitygroupname;
    $acs_enablepassword ||= $defaultacs->enablepassword;
    $acs_passwordneverexpires ||=  $defaultacs->passwordneverexpires;
    $acs_dateexceedsenabled ||= $defaultacs->dateexceedsenabled;
    $acs_dateexceeds ||=  $defaultacs->dateexceeds;
    $acs_passwordtype ||= $defaultacs->passwordtype;
  }

  if ($acs_toggle)
  { $self->db->resultset('DsAcsUser')->create(
      { enabled => $acs_enabled, description => $acs_description, identitygroupname => $acs_identitygroupname,
        enablepassword => $acs_enablepassword, passwordneverexpires => $acs_passwordneverexpires,
        dateexceedsenabled => $acs_dateexceedsenabled, dateexceeds => $acs_dateexceeds, passwordtype => $acs_passwordtype,
        name => $name, password => $acs_password, id => $acsmaxid, status => $status_created,
        # TODO Add support for UID!
        #source => 
      });
  }
  
  my $ise_password = $self->param("ise_password") || $password;
  my $ise_enabled = $self->param("ise_enabled");
  my $ise_firstname = $self->param("ise_firstname");
  my $ise_lastname = $self->param("ise_lastname"); 
  my $ise_identitygroups = $self->param("ise_identitygroups");
  my $ise_email = $self->param("ise_email");
  my $ise_enablepassword = $self->param("ise_enablepassword");
  my $ise_changepassword = $self->param("ise_changepassword");
  my $ise_expirydateenabled = $self->param("ise_expirydateenabled");
  my $ise_expirydate = $self->param("ise_expirydate");
  my $ise_passwordidstore = $self->param("ise_passwordidstore");

  if ($defaultise) 
  { $ise_enabled ||= $defaultise->enabled;
    $ise_firstname ||= $defaultise->firstname;
    $ise_lastname ||= $defaultise->lastname; 
    $ise_identitygroups ||= $defaultise->identitygroups;
    $ise_email ||= $defaultise->email;  
    $ise_enablepassword ||= $defaultise->enablepassword;
    $ise_changepassword ||= $defaultise->changepassword;
    $ise_expirydateenabled ||= $defaultise->expirydateenabled;
    $ise_expirydate ||= $defaultise->expirydate;
    $ise_passwordidstore ||= $defaultise->passwordidstore;
  }

  my $encisepassword = encode_base64($self->cipher->encrypt($self->salt.$ise_password.$name));

  if ($ise_toggle)
  {  $self->db->resultset('DsIseInternaluser')->create(
        { enabled => $ise_enabled, firstname => $ise_firstname, lastname => $ise_lastname,
          identitygroups => $ise_identitygroups, email => $ise_email, enablepassword => $ise_enablepassword,
          changepassword => $ise_changepassword, expirydateenabled => $ise_expirydateenabled, expirydate=> $ise_expirydate,
          passwordidstore => $ise_passwordidstore, name => $name, password => $encisepassword, id => $isemaxid, status => $status_created,
          # TODO Add support for UID!
        });
  }
  my $im_password = $self->param("im_password") || $password;  
  my $intermapper_groups = $self->param("intermapper_groups");
  my $intermapper_guest = $self->param("intermapper_guest");
  my $intermapper_external = $self->param("intermapper_external");
  
  my $encimpassword = encode_base64($self->cipher->encrypt($self->salt.$im_password.$name));  
  
  if ($defaultintermapper)
  { $intermapper_groups ||= $defaultintermapper->groups;
    $intermapper_guest ||= $defaultintermapper->guest;
    $intermapper_external ||= $defaultintermapper->external;
  }
  if ($im_toggle)
  {  $self->db->resultset('DsIntermapperUser')->create(
    { groups => $intermapper_groups, external => $intermapper_external, guest => $intermapper_guest,
      name => $name, password => $encimpassword, id => $immaxid, status => $status_created,
      # TODO Add support for UID!
    });
  }
  
  $self->redirect_to("/accounts/");
}

sub update { # PUT /accounts/123 - update a account
  my $self = shift;
  $self->redirect_to('/login/') if !$self->session('logged_in');
  my $id = $self->param("id");

  my $param = $self->req->params->names;
  my @paramnames = @{$param};

  # Accounts table update is REQUIRED STILL!!
  # Temporary fix
  my $immax = $self->db->resultset('DsIntermapperUser')->get_column('Id');
  my $immaxid = $immax->max;
  # TODO Add support for UID!
  #$immaxid++;
  # BUG
  # Intermapper IDs are random IDs
  
  # Temporary fix
  my $isemax = $self->db->resultset('DsIseIdentitygroup')->get_column('Id');
  my $isemaxid = $isemax->max;
  $isemaxid++;  

  my @acs_uid = @{ $self->every_param('acs_uid') };
  my @ise_uid = @{ $self->every_param('ise_uid') };
  my @im_uid = @{ $self->every_param('im_uid') };
  my $im_toggle = $self->param("im_toggle") || "0";
  my $password = $self->param("password");
  my $authentication = $self->param("authentication");
  my $name = $self->param("name");
  my $encpassword = encode_base64($self->cipher->encrypt($self->salt.$password.$name));
  
  for my $uid (@acs_uid)
  { if ($uid =~ /\-X$/) { $uid = ""; next; }
    my $acs_toggle = $self->param("acs_toggle_".$uid) || "0";
    my $acs_password = $self->param("acs_password_".$uid) || $password;
    my $encacspassword = encode_base64($self->cipher->encrypt($self->salt.$acs_password.$name));
    my $acs_enabled = $self->param("acs_enabled_".$uid);  
    my $acs_description = $self->param("acs_description_".$uid);
    my $acs_identitygroupname = $self->param("acs_identitygroupname_".$uid);
    my $acs_enablepassword = $self->param("acs_enablepassword_".$uid);
    my $acs_encenablepassword = encode_base64($self->cipher->encrypt($self->salt.$acs_enablepassword.$name));
    my $acs_passwordneverexpires = $self->param("acs_passwordneverexpires_".$uid);
    my $acs_dateexceedsenabled = $self->param("acs_dateexceedsenabled_".$uid);
    my $acs_dateexceeds = $self->param("acs_dateexceeds_".$uid);
    my $acs_passwordtype = $self->param("acs_passwordtype_".$uid);

    my $acs_rs = $self->db->resultset('DsAcsUser');
    my $query_rs = $acs_rs->search({ uid => $uid });
    $encacspassword = $acs_password eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->password : $encacspassword;
    $acs_encenablepassword = $acs_enablepassword eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->enablepassword : $acs_enablepassword;
    
    my $checksum = md5_hex($name.$encacspassword.$acs_enabled.$acs_description.$acs_identitygroupname.$acs_enablepassword.$acs_passwordneverexpires.$acs_dateexceedsenabled.
                         $acs_dateexceeds.$acs_passwordtype);
  
    # Need to store full datetime instead of date
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
    $mon++;
    $year += 1900;  
    my @months = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec); 
    my $lastmodified = "$months[$mon] $mday $year $hour:$min:$sec";
    my $created = "$months[$mon] $mday $year $hour:$min:$sec";
  
    if ($uid && $acs_toggle)
    { $accounts->{$id}{"acs"}{$uid}{"enabled"} = $acs_enabled;
      $accounts->{$id}{"acs"}{$uid}{"description"} = $acs_description;
      $accounts->{$id}{"acs"}{$uid}{"identitygroupname"} = $acs_identitygroupname;
      $accounts->{$id}{"acs"}{$uid}{"enablepassword"} = $acs_encenablepassword;
      $accounts->{$id}{"acs"}{$uid}{"passwordneverexpires"} = $acs_passwordneverexpires;
      $accounts->{$id}{"acs"}{$uid}{"dateexceedsenabled"} = $acs_dateexceedsenabled;
      $accounts->{$id}{"acs"}{$uid}{"dateexceeds"} = $acs_dateexceeds;
      $accounts->{$id}{"acs"}{$uid}{"passwordtype"} = $acs_passwordtype;
      $accounts->{$id}{"acs"}{$uid}{"lastmodified"} = $lastmodified;
      $accounts->{$id}{"acs"}{$uid}{"password"} = $encacspassword;
    
      $query_rs->first->update({ enabled => $acs_enabled, description => $acs_description, identitygroupname => $acs_identitygroupname,
                       enablepassword => $acs_encenablepassword, passwordneverexpires => $acs_passwordneverexpires,
                       dateexceedsenabled => $acs_dateexceedsenabled, dateexceeds => $acs_dateexceeds, passwordtype => $acs_passwordtype,
                       name => $name, password => $encacspassword, status => $status_changed, lastmodified => $lastmodified, checksum => $checksum
                    });
    }
    if (!$uid && $acs_toggle) # TODO: UID is, at this point, ALWAYS defined!!
    { if ($acs_enabled || $acs_description || $acs_identitygroupname || $acs_encenablepassword || $acs_passwordneverexpires || $acs_dateexceedsenabled ||
          $acs_dateexceeds || $acs_passwordtype)
      { $self->db->resultset('DsAcsUser')->create(
        { enabled => $acs_enabled, description => $acs_description, identitygroupname => $acs_identitygroupname,
          enablepassword => $acs_encenablepassword, passwordneverexpires => $acs_passwordneverexpires,
          dateexceedsenabled => $acs_dateexceedsenabled, dateexceeds => $acs_dateexceeds, passwordtype => $acs_passwordtype, checksum => $checksum,
          name => $name, password => $encacspassword, status => $status_created, id => $immaxid, lastmodified => $lastmodified, created => $created
        });
        $accounts->{$uid}{"acs_created"} = $created;
      }
    }
  
    if ($uid && !$acs_toggle)  
    { my $acs_rs = $self->db->resultset('DsAcsUser');
      my $query_rs = $acs_rs->search({ uid => $uid });
      #$query_rs->delete;
      $query_rs->first->update(status => $status_deleted );
      delete($acsaccounts->{$uid});
      # TODO Add support for delete flag & remove hash delete
      $accounts->{$uid}{"acs"} = 0;
    }
  }
  
  for my $uid (@ise_uid)
  { if ($uid =~ /\-X$/) { $uid = ""; next; }
    my $ise_toggle = $self->param("ise_toggle_".$uid) || "0";
    my $ise_password = $self->param("ise_password_".$uid) || $password;
    my $encisepassword = encode_base64($self->cipher->encrypt($self->salt.$ise_password.$name));
    my $ise_enabled = $self->param("ise_enabled_".$uid);
    my $ise_firstname = $self->param("ise_firstname_".$uid);
    my $ise_lastname = $self->param("ise_lastname_".$uid); 
    my $ise_identitygroups = $self->param("ise_identitygroups_".$uid);
    my $ise_email = $self->param("ise_email_".$uid);  
    my $ise_enablepassword = $self->param("ise_enablepassword_".$uid);
    my $ise_encenablepassword = encode_base64($self->cipher->encrypt($self->salt.$ise_enablepassword.$name));

    my $ise_rs = $self->db->resultset('DsIseInternaluser');
    my $query_rs = $ise_rs->search({ uid => $uid });
    $encisepassword = $ise_password eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->password : $encisepassword;
    $ise_encenablepassword = $ise_enablepassword eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->enablepassword : $ise_enablepassword;
        
    my $ise_changepassword = $self->param("ise_changepassword");
    my $ise_expirydateenabled = $self->param("ise_expirydateenabled");
    my $ise_expirydate = $self->param("ise_expirydate");
    my $ise_passwordidstore = $self->param("ise_passwordidstore");
    my $checksum = md5_hex($name.$encisepassword.$ise_enabled.$ise_firstname.$ise_lastname.$ise_identitygroups.$ise_email.$ise_encenablepassword.
                      $ise_changepassword.$ise_expirydateenabled.$ise_expirydate.$ise_passwordidstore);
    if ($uid && $ise_toggle)
    { $accounts->{$id}{"ise"}{$uid}{"enabled"} = $ise_enabled;
      $accounts->{$id}{"ise"}{$uid}{"firstname"} = $ise_firstname;
      $accounts->{$id}{"ise"}{$uid}{"lasttname"} = $ise_lastname;    
      $accounts->{$id}{"ise"}{$uid}{"identitygroups"} = $ise_identitygroups;
      $accounts->{$id}{"ise"}{$uid}{"email"} = $ise_email;    
      $accounts->{$id}{"ise"}{$uid}{"enablepassword"} = $ise_encenablepassword;
      $accounts->{$id}{"ise"}{$uid}{"changepassword"} = $ise_changepassword;
      $accounts->{$id}{"ise"}{$uid}{"expirydateenabled"} = $ise_expirydateenabled;
      $accounts->{$id}{"ise"}{$uid}{"expirydate"} = $ise_expirydate;
      $accounts->{$id}{"ise"}{$uid}{"passwordidstore"} = $ise_passwordidstore;
      $accounts->{$id}{"ise"}{$uid}{"password"} = $encisepassword;
      if ($query_rs)
      { $query_rs->first->update({ enabled => $ise_enabled, firstname => $ise_firstname, lastname => $ise_lastname,
                       identitygroups => $ise_identitygroups, email => $ise_email, enablepassword => $ise_encenablepassword,
                       changepassword => $ise_changepassword, expirydateenabled => $ise_expirydateenabled, expirydate=> $ise_expirydate,
                       passwordidstore => $ise_passwordidstore, name => $name, password => $encisepassword, status => $status_changed, checksum => $checksum
                    });
      }
    }
  
    if (!$uid && $ise_toggle) # TODO: UID is, at this point, ALWAYS defined!!
    { if ($ise_enabled || $ise_firstname || $ise_lastname || $ise_identitygroups || $ise_email || $ise_encenablepassword ||
          $ise_changepassword || $ise_expirydateenabled || $ise_expirydate || $ise_passwordidstore)
        { $self->db->resultset('DsIseInternaluser')->create(
          { enabled => $ise_enabled, firstname => $ise_firstname, lastname => $ise_lastname,
            identitygroups => $ise_identitygroups, email => $ise_email, enablepassword => $ise_encenablepassword,
            changepassword => $ise_changepassword, expirydateenabled => $ise_expirydateenabled, expirydate=> $ise_expirydate,
            passwordidstore => $ise_passwordidstore, name => $name, password => $encisepassword, status => $status_created, id => $isemaxid, checksum => $checksum
          });    
       }
    }

    if ($uid && !$ise_toggle)  
    { my $ise_rs = $self->db->resultset('DsIseInternaluser');
      my $query_rs = $ise_rs->search({ uid => $uid });
      #$query_rs->delete;
      # TODO Add support for delete flag & remove hash delete
      delete($iseaccounts->{$uid});
      $query_rs->first->update(status => $status_deleted );
      $accounts->{$uid}{"ise"} = 0;
    }
  }

  for my $uid (@im_uid)  
  { my $im_password = $self->param("intermapper_password_".$uid) || $password;
    my $encimpassword = encode_base64($self->cipher->encrypt($self->salt.$im_password.$name));

    my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
    my $query_rs = $intermapper_rs->search({ uid => $uid });
    $encimpassword = $im_password eq "PASSWORDHASBEENCHANGED!!" ? $query_rs->first->password : $encimpassword;

    my $intermapper_groups = $self->param("intermapper_groups_".$uid);
    my $intermapper_guest = $self->param("intermapper_guest_".$uid);
    my $intermapper_external = $self->param("intermapper_external_".$uid);
    my $checksum = md5_hex($name.$encimpassword.$intermapper_groups.$intermapper_guest.$intermapper_external);
  
    if ($uid && $im_toggle)
    { if ($uid =~ /\-X$/) { $uid = ""; next; }
      $accounts->{$uid}{"intermapper_groups"} = $intermapper_groups;
      $accounts->{$uid}{"intermapper_guest"} = $intermapper_guest;
      $accounts->{$uid}{"intermapper_external"} = $intermapper_external;
      $accounts->{$uid}{"intermapper_password"} = $encimpassword;

      $query_rs->first->update({ groups => $intermapper_groups, external => $intermapper_external, guest => $intermapper_guest,
                      name => $name, password => $encimpassword, status => $status_changed, checksum => $checksum
                    });
    }
  
    if (!$uid && $im_toggle)
    { if ($intermapper_groups || $intermapper_guest || $intermapper_external || $im_password )
      {  $self->db->resultset('DsIntermapperUser')->create(
          { groups => $intermapper_groups, external => $intermapper_external, guest => $intermapper_guest,
            name => $name, password => $encimpassword, status => $status_created, id => $immaxid, checksum => $checksum
         });
      }
    }
  
    if ($uid && !$im_toggle)  
    { my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
      my $query_rs = $intermapper_rs->search({ uid => $uid });
      #$query_rs->delete;
      $query_rs->first->update(status => $status_deleted );
      delete($intermapperaccounts->{$uid});
      # TODO Add support for delete flag & remove hash delete
      $accounts->{$uid}{"intermapper"} = 0;
    }
  }
  
  $self->consolidate();
  
  $accounts->{$id}{"name"} = $name;
  $accounts->{$id}{"password"} = $encpassword if $password;
  $accounts->{$id}{"authentication"} = $authentication;

  my $account_rs = $self->db->resultset('Account');
  my $query_rs = $account_rs->search({ name => $id }); 
  if ($password)
  { $query_rs->update({ name => $name, password => $encpassword, authentication => $authentication }); }
  else
  { $query_rs->update({ name => $name, authentication => $authentication }); }  

  $self->redirect_to("/accounts/$id");
}

sub delete { # DELETE /accounts/123 - delete a account - Also multi-selected IDs from listing!
  my $self = shift;
  $self->redirect_to('/login/') if !$self->session('logged_in');  
  my $uid = $self->param("uid");
  my @extraid = @ { $self->every_param("extraid") };
  unshift(@extraid, $uid);
  for my $uid (@extraid)
  { delete($accounts->{$uid});
    my $account_rs = $self->db->resultset('Account');
    my $query_rs = $account_rs->search({ name => $uid }); # BUG again??!?! See a few lines up!
    if ($query_rs)
    { $query_rs->delete; # TODO Implement delete flag and remove DB delete
    }
    
    my $ise_rs = $self->db->resultset('DsIseInternaluser');
    $query_rs = $ise_rs->search({ name => $uid });
    if ($query_rs)
    { $query_rs->delete; # TODO Implement delete flag and remove DB delete
    }
    delete($iseaccounts->{$uid}); # TODO Implement delete flag and remove DB delete
      
    my $acs_rs = $self->db->resultset('DsAcsUser');
    $query_rs = $acs_rs->search({ name => $uid }); # BUG again?!?!?! See a few lines up!
    if ($query_rs)
    { $query_rs->delete; # TODO Implement delete flag and remove DB delete
    }
    delete($acsaccounts->{$uid}); # TODO Implement delete flag and remove DB delete
  
    my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
    $query_rs = $intermapper_rs->search({ name => $uid }); # BUG again ?!?!?!? See a few lines up!
    if ($query_rs)
    { $query_rs->delete; # TODO Implement delete flag and remove DB delete
    }
    delete($intermapperaccounts->{$uid}); # TODO Implement delete flag and remove DB delete
  }
  $self->redirect_to("/accounts/");
}

sub consolidate {
  my $self = shift;
  # Consolidate based on account login..
  $self->redirect_to('/login/') if !$self->session('logged_in');
  my %datasources = $self->datasources;
  my $sources_rs = $self->db->resultset('DsSource');
  my $query_rs = $sources_rs->search;
  my %sources = ();

  while (my $source = $query_rs->next)
  { $sources{$source->id} = $source;
  }

  $accounts = {};
  my $account_rs = $self->db->resultset('Account');
  $query_rs = $account_rs->search;
  while (my $account = $query_rs->next)
  { $accounts->{$account->name}{"name"} = $account->name if $account->name;
  }
  
  my $acs_rs = $self->db->resultset('DsAcsUser');
  $query_rs = $acs_rs->search;
  while (my $account = $query_rs->next)
  { $acsaccounts->{$account->name}{$account->uid} = $account if $account->name;
    for my $source (keys %sources)
    { $accounts->{$account->name}{"stub_ise"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ISE";
      $accounts->{$account->name}{"stub_intermapper"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "Intermapper";
    }
  }
  
  my $ise_rs = $self->db->resultset('DsIseInternaluser');
  $query_rs = $ise_rs->search;
  while (my $account = $query_rs->next)
  { $iseaccounts->{$account->name}{$account->uid} = $account if $account->name;
    for my $source (keys %sources)
    { $accounts->{$account->name}{"stub_acs"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ACS";
      $accounts->{$account->name}{"stub_intermapper"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "Intermapper";
    }
  }

  my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
  $query_rs = $intermapper_rs->search;
  while (my $account = $query_rs->next)
  { $intermapperaccounts->{$account->name}{$account->uid} = $account if $account->name;
    for my $source (keys %sources)
    { $accounts->{$account->name}{"stub_ise"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ISE";
      $accounts->{$account->name}{"stub_acs"}{$sources{$source}->id."-X"}{"source"} = $sources{$source} if $sources{$source}->type->shortname eq "ACS";
    }
  }

  my %acs = ();
  my %intermapper = ();
  my %ise = ();
  for my $db ($acsaccounts, $iseaccounts, $intermapperaccounts)
  { for my $key (keys %{$db})
    { for my $uid (keys %{$db->{$key}}) # UIDs = Users
      { if (ref($db->{$key}{$uid}) eq "NG::Schema::Result::DsAcsUser")
        { if (!$accounts->{$db->{$key}{$uid}->name}{"name"})
          { $accounts->{$db->{$key}{$uid}->name}{"name"} = $db->{$key}{$uid}->name;
            $accounts->{$db->{$key}{$uid}->name}{"password"} = $db->{$key}{$uid}->password || "";
          }
          $accounts->{$db->{$key}{$uid}->name}{"password"} ||= "";
          #$accounts->{$db->{$key}{$uid}->name}{"acs"} = 1;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"status"} = 1;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"description"} = $db->{$key}{$uid}->description;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"identitygroupname"} = $db->{$key}{$uid}->identitygroupname->name;
          # Table relationship to ds_acs_identitygroup
          # THIS one is a strange fix for the way DBIX::Class handles has_many with singular and plural names - Tricky part is for ISE more than for ACS!
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"enabled"} = bool($db->{$key}{$uid}->enabled);
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"enablepassword"} = $db->{$key}{$uid}->enablepassword;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"passwordneverexpires"} = bool($db->{$key}{$uid}->passwordneverexpires);
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"password"} = $db->{$key}{$uid}->password;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"passwordtype"} = $db->{$key}{$uid}->passwordtype;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"dateexceeds"} = $db->{$key}{$uid}->dateexceeds;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"dateexceedsenabled"} = bool($db->{$key}{$uid}->dateexceedsenabled);
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"id"} = $db->{$key}{$uid}->id;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"uid"} = $db->{$key}{$uid}->uid;
          $accounts->{$db->{$key}{$uid}->name}{"acs"}{$uid}{"source"} = $db->{$key}{$uid}->source;
          $acs{$db->{$key}{$uid}->name}  = 1;
          
        }
        if (ref($db->{$key}{$uid}) eq "NG::Schema::Result::DsIntermapperUser")
        { if (!$accounts->{$db->{$key}{$uid}->name}{"name"})
          { $accounts->{$db->{$key}{$uid}->name}{"name"} = $db->{$key}{$uid}->name;
            $accounts->{$db->{$key}{$uid}->name}{"password"} = $db->{$key}{$uid}->password || "";
          }
          $accounts->{$db->{$key}{$uid}->name}{"password"} ||= "";
          #$accounts->{$db->{$key}->name}{"intermapper"} = 1;
          $accounts->{$db->{$key}{$uid}->name}{"intermapper_status"} = 1;
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"groups"} = $db->{$key}{$uid}->groups || "";
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"external"} = bool($db->{$key}{$uid}->external);
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"guest"} = $db->{$key}{$uid}->guest;
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"uid"} = $db->{$key}{$uid}->uid;
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"id"} = $db->{$key}{$uid}->id;
          $accounts->{$db->{$key}{$uid}->name}{"intermapper"}{$uid}{"source"} = $db->{$key}{$uid}->source;
          $intermapper{$db->{$key}{$uid}->name} = 1;
          
          $accounts->{$db->{$key}{$uid}->name}{"stub_intermapper"}{$uid}{"source"} = $db->{$key}{$uid}->source;
        }
        if (ref($db->{$key}{$uid}) eq "NG::Schema::Result::DsIseInternaluser")
        { if (!$accounts->{$db->{$key}{$uid}->name}{"name"})
          { $accounts->{$db->{$key}{$uid}->name}{"name"} = $db->{$key}{$uid}->name;
            $accounts->{$db->{$key}{$uid}->name}{"password"} = $db->{$key}{$uid}->password;
          }
          $accounts->{$db->{$key}{$uid}->name}{"password"} ||= "";
          $accounts->{$db->{$key}{$uid}->name}{"ise_status"} = 1;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"email"} = $db->{$key}{$uid}->email; 
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"firstname"} = $db->{$key}{$uid}->firstname;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"lastname"} = $db->{$key}{$uid}->lastname;        
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"identitygroups"} = $db->{$key}{$uid}->identitygroup->name;
          # Table relationship to ds_ise_identitygroup
          # THIS one is a strange fix for the way DBIX::Class handles has_many with singular and plural names!
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"changepassword"} = bool($db->{$key}{$uid}->changepassword);
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"enabled"} = bool($db->{$key}{$uid}->enabled);
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"enablepassword"} = $db->{$key}{$uid}->enablepassword;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"password"} = $db->{$key}{$uid}->password;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"passwordidstore"} = $db->{$key}{$uid}->passwordidstore;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"expirydate"} = $db->{$key}{$uid}->expirydate;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"expirydateenabled"} = bool($db->{$key}{$uid}->expirydateenabled);
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"id"} = $db->{$key}{$uid}->id;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"uid"} = $db->{$key}{$uid}->uid;
          $accounts->{$db->{$key}{$uid}->name}{"ise"}{$uid}{"source"} = $db->{$key}{$uid}->source;
          $ise{$db->{$key}{$uid}->name} = 1;
        }
      }

      # TODO: FIX THIS AND USE SEPARATE UID TO IDENTIFY CORRECT DATA SOURCE
      for my $source (keys %datasources)
      { if (ref($datasources{$source}) eq "Net::Cisco::ACS")
        { #$acs->users(users => \%acs);
        }
        if (ref($datasources{$source}) eq "Net::Cisco::ISE")
        { #$ise->internalusers(internalusers => \%ise);
        }
        if (ref($datasources{$source}) eq "Net::Intermapper")
        { #$intermapper->users(\%intermapper);
        }
      }      
    }
  }
}

sub bool
{ return " checked" if $_[0];
}

# This is used by mapping!! 
sub synchronize # REVIEW!!
{ my $self = shift;
  $self->redirect_to('/login/') if !$self->session('logged_in'); 
  my $filter = $self->param("filter");
  my @mappings = ();
  
  my $mapping_rs = $self->db->resultset('Mapping');
  my $query_rs = $mapping_rs->search({ source_table => "Users" });
  while (my $mapping = $query_rs->next)
  { my ($source_ds, $source_table, $source_field, $destination_ds, $destination_table, $destination_field, $create, $append, $overwrite) =
   ($mapping->source_ds, $mapping->source_table, $mapping->source_field, $mapping->destination_ds, $mapping->destination_table,
    $mapping->destination_field, $mapping->createflag, $mapping->appendflag, $mapping->overwriteflag);
    push(@mappings,
         { source_ds => $source_ds, source_table => $source_table, source_field => $source_field,
           destination_ds => $destination_ds, destination_table => $destination_table, destination_field => $destination_field,
           create => $create, append => $append, overwrite => $overwrite
         });
  }
  
  my $acs_rs = $self->db->resultset('DsAcsUser');
  $query_rs = $acs_rs->search;
  while (my $account = $query_rs->next)
  { my %account = $account->get_columns;
    for my $map (@mappings)
    { if  ($map->{source_ds} == 1)  # ACS
      { if (my ($sfield) = $map->{source_field} =~ /^dynamic: (.*)$/) # Source field dynamic - Probably only for name
        { if (my ($dfield, $dvalue) = $map->{destination_field} =~ /^dynamic: (\S*)\s?(\S*)$/) # Destination field dynamic - Probably only for name
          { # ACS to Intermapper
            $sfield =~ s/[\r\n]//g; $dfield =~ s/[\r\n]//g;
            if ($map->{destination_ds} == 2)
            { my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
              my %criteria = (); #($dfield => $account{$sfield});
              $criteria{"name"} = $account{"name"};
              my $im_rs = $intermapper_rs->search({ %criteria }); # find all IM records with name matching sourcd DS, create if needed
              my $empty = 1;
              while (my $imaccount = $im_rs->next)
              { if ($map->{"overwrite"} eq "1") # APPEND FUNCTIONALITY TO DO!!
                { if (!$dvalue)
                  { $imaccount->update({ $dfield => $account{"$sfield"} }) ; } else
                  { $dvalue =~ s/\"//g; $imaccount->update({ $dfield => $dvalue }) ; }
                }
                $empty = 0;
              }
              if ($empty)  # No records matching criteria already exist - insert!
              { if ($map->{"create"} eq "1") 
                { $self->db->resultset('DsIntermapperUser')->create({ $dfield => $account{"acs_$sfield"} });
                }
              }
            }
            # ACS to ISE
            
            if ($map->{destination_ds} == 3)
            { my $ise_rs = $self->db->resultset('DsIseInternaluser');
              my %criteria = (); #($dfield => $account{$sfield});
              # if ($sfield ne "name") # Onlu use NAME field!!
              $criteria{"name"} = $account{"name"}; 
              my $cise_rs = $ise_rs->search({ %criteria });
              my $empty = 1;
              while (my $iseaccount = $cise_rs->next)
              { if ($map->{"overwrite"} eq "1") # APPEND FUNCTIONALITY TO DO!!
                { if (!$dvalue)
                 { $iseaccount->update({ $dfield => $account{"$sfield"} }) ; } else
                 { $dvalue =~ s/\"//g; $iseaccount->update({ $dfield => $dvalue }) ;
                 } 
                }
                $empty = 0;
              }
              if ($empty) 
              { if ($map->{"create"} eq "1")
                { $self->db->resultset('DsIseInternaluser')->create({ $dfield => $account{"acs_$sfield"} });
                }
              }
            }

          }
          
        } # source_field and destination_field dynamic
                
        if (my ($sfield, $svalue) = $map->{source_field} =~ /^static: (.*?) \"(.*?)\"$/) # Source field static - Probably only for name
        { if (my ($dfield,$dvalue) = $map->{destination_field} =~ /^static: (.*?) \"(.*?)\"$/) # Destination field static - Probably only for name
          { # ACS to Intermapper
            if ($map->{destination_ds} == 2)
            { if ($svalue && $account{"$sfield"} && $account{"$sfield"} eq $svalue)
              { my $intermapper_rs = $self->db->resultset('DsIntermapperUser');
                my %criteria = ("name" => $account{"name"}); # Find record in IM db matchin name
                my $im_rs = $intermapper_rs->search({ %criteria });
                if ($im_rs) # Records matching criteria already exist - only update!
                { while (my $imaccount = $im_rs->next)
                  { if ($map->{"append"} eq "1")
                    { $dvalue = $dvalue && $imaccount->{$dfield} ? $imaccount->{$dfield}.$dvalue : $imaccount->{$dfield};
                      $imaccount->update({ $dfield => $dvalue }) ;
                    }
                    if ($map->{"overwrite"} eq "1")
                    { $imaccount->update({ $dfield => $dvalue }) ;
                    }
                  }
                } else  # No records matching criteria already exist - insert!
                { if ($map->{"create"} eq "1")
                  { $self->db->resultset('DsIntermapperUser')->create({ "name" => $account{"name"}, $dfield => $dvalue });
                  }
                }
              }
            }

            # ACS to ISE
            if ($map->{destination_ds} == 3)
            { my $svfield = $account{"$sfield"} || "";
              if ($svalue eq $svfield)
              { my $ise_rs = $self->db->resultset('DsIseInternaluser');
                my %criteria = ("name" => $account{"name"}); # Find record in IM db matchin name
                my $cise_rs = $ise_rs->search({ %criteria });
                if ($cise_rs) # Records matching criteria already exist - only update!
                { while (my $iseaccount = $cise_rs->next)
                  { if ($map->{"append"} eq "1")
                    { $dvalue ||= "";
                      $iseaccount->{$dfield} ||= "";
                      $iseaccount->update({ $dfield => $iseaccount->{$dfield}.$dvalue }) ;
                    }
                    if ($map->{"overwrite"} eq "1")
                    { $iseaccount->update({ $dfield => $dvalue }) ;
                    }
                  }
                } else  # No records matching criteria already exist - insert!
                { if ($map->{"create"} eq "1")
                  { $self->db->resultset('DsIseInternaluser')->create({ "name" => $account{"name"}, $dfield => $dvalue });
                  }
                }
              }
            }
          }
        } # source_field and destination_field static
        
      } # source_ds = 1      
    }
  }

  if ($filter)
  { $self->redirect_to("/accounts/?filter=$filter");
  } else
  { $self->redirect_to("/accounts/"); }
}

1;
